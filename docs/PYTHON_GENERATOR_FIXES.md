# Python Generator Fixes - Analysis and Solutions

## Issues Identified from Generated Python Output

### 1. ❌ Variable Initialization to None
**Problem:**
```python
vpp = None
frame = None
hits = None
```

**Root Cause:** Blockly's default Python generator initializes all variables declared in `<variables>` section to `None`.

**Fix Applied:**
- Overrode `variables_get` generator to prevent None initialization
- Variables are now only assigned when explicitly set via `variables_set` blocks
- Variables are used directly without pre-initialization

**Result:**
```python
# Variables are NOT initialized to None
# They are assigned when used:
vpp = float(scope.query(':MEASUREMENT:IMMED:VALUE?').strip())
```

### 2. ❌ Missing Type Hints for tm_devices
**Problem:**
```python
scope: MSO6B = device_manager.add_scope("192.168.1.10")
# But generator was defaulting to MSO6B even when not specified
```

**Root Cause:** Generator was defaulting `DRIVER_NAME` to 'MSO6B' even when not explicitly set in XML.

**Fix Applied:**
- Changed default from `'MSO6B'` to `''` (empty string)
- Type hints are now only added when `DRIVER_NAME` is explicitly provided in XML
- If not provided, no type hint is generated

**Result:**
```python
# Without DRIVER_NAME in XML:
scope = device_manager.add_scope("192.168.1.10")

# With DRIVER_NAME="MSO6B" in XML:
scope: MSO6B = device_manager.add_scope("192.168.1.10")
```

### 3. ❌ Verbose OPC Wait Pattern
**Problem:**
```python
start_time = time.time()
while time.time() - start_time < 30:
    if scope.query('*OPC?').strip() == '1':
        break
    time.sleep(0.1)
else:
    print("Warning: OPC timeout on scope")
```

**Root Cause:** Generator was using polling pattern for all backends, even tm_devices.

**Fix Applied:**
- For tm_devices: Use cleaner pattern with `write('*OPC?')` + `read()`
- For PyVISA: Keep polling pattern (required for some VISA implementations)
- Detection based on device backend

**Result (tm_devices):**
```python
# Wait for operation complete on scope
scope.write('*OPC?')
response = scope.read()
if response.strip() != '1':
    print("Warning: OPC did not return 1 on scope")
```

### 4. ❌ Single Acquisition + OPC Not Combined
**Problem:**
```python
# Single acquisition on scope
scope.write('ACQUIRE:STOPAFTER SEQUENCE')
scope.write('ACQUIRE:STATE RUN')
# Wait for operation complete on scope
start_time = time.time()
while time.time() - start_time < 30:
    ...
```

**Root Cause:** `single_acquisition` and `wait_for_opc` were generating separate commands instead of combining them.

**Fix Applied:**
- `single_acquisition` now detects if next block is `wait_for_opc`
- If detected, marks itself to skip and returns empty
- `wait_for_opc` detects `single_acquisition` in previous block
- Generates combined command: `ACQUIRE:STOPAFTER SEQUENCE` + `ACQUIRE:STATE ON;*OPC?` + `read()`

**Result:**
```python
# Single acquisition and wait for completion on scope
scope.write('ACQUIRE:STOPAFTER SEQUENCE')
scope.write('ACQUIRE:STATE ON;*OPC?')
scope.read()  # Block until acquisition complete
```

### 5. ✅ Cleanup Section (Already Working)
**Status:** Cleanup section is correctly generating device close code.

**Current Output:**
```python
# Cleanup - close all devices
if 'scope' in locals():
    scope.close()
    print("Disconnected scope")

# Close DeviceManager
if 'device_manager' in locals():
    device_manager.close()
    print("DeviceManager closed")
```

**This is correct and working as intended.**

### 6. ⚠️ XML Issue: Missing Loop Variable Mutation
**Problem in GPT-generated XML:**
```xml
<block type="controls_for" id="loop1">
  <field name="VAR">frame</field>
  <!-- MISSING: <mutation><variable>frame</variable></mutation> -->
```

**Root Cause:** Custom GPT is not generating the mutation element for loop variables.

**Impact:** Blockly may not properly track the loop variable, but Python generator should still work.

**Fix Needed:** Update Custom GPT instructions to include mutation in loop examples.

**Temporary Workaround:** Generator should handle this gracefully (uses VAR field as fallback).

## Additional Improvements Made

### 1. Better OPC Pattern for tm_devices
- Cleaner `write('*OPC?')` + `read()` pattern instead of polling
- More efficient and cleaner code

### 2. Acquisition Block Combination
- `single_acquisition` + `wait_for_opc` now properly combine
- Reduces redundant code generation

### 3. Type Hint Control
- Only adds type hints when explicitly requested
- Prevents unnecessary type hints in generated code

### 4. Variable Initialization Prevention
- Variables no longer initialized to None
- Cleaner code, variables assigned when used

## Expected Output After Fixes

```python
#!/usr/bin/env python3
"""
Generated by TekAutomate - Blockly Builder
Generated: 2026-01-25T08:22:05.121Z
"""

import time
from tm_devices import DeviceManager

# Initialize tm_devices DeviceManager
device_manager = DeviceManager(verbose=True)
device_manager.setup_cleanup_enabled = True
device_manager.teardown_cleanup_enabled = True

# Connect to scope using tm_devices
scope = device_manager.add_scope("192.168.1.10")
print(f"Connected to scope: {scope.query('*IDN?').strip()}")

# Enable FastFrame mode on scope
scope.write(':HORIZONTAL:FASTFRAME:STATE ON')
# Set FastFrame count on scope
scope.write(f':HORIZONTAL:FASTFRAME:COUNT {50}')
# Configure edge search 1 on scope
scope.write(':SEARCH:SEARCH1:EDGE:SOURCE CH1')
scope.write(':SEARCH:SEARCH1:EDGE:SLOPE FALL')
# Reset acquisition state on scope
scope.write('ACQuire:STATE OFF')
# Single acquisition and wait for completion on scope
scope.write('ACQUIRE:STOPAFTER SEQUENCE')
scope.write('ACQUIRE:STATE ON;*OPC?')
scope.read()  # Block until acquisition complete
# Immediate PK2PK measurement on CH1 from scope
scope.write(':MEASUREMENT:IMMED:TYPE PK2PK')
scope.write(':MEASUREMENT:IMMED:SOURCE CH1')
vpp = float(scope.query(':MEASUREMENT:IMMED:VALUE?').strip())
print(f"PK2PK on CH1: {vpp}")
for frame in range(1, 51):
    # Select FastFrame frame for CH1 on scope
    scope.write(f':HORIZONTAL:FASTFRAME:SELECTED:CH1 {frame}')
    # Query search 1 total on scope
    hits = scope.query(':SEARCH:SEARCH1:TOTAL?').strip()
    print(f"Search 1 total: {hits}")
    scope.save_screenshot(f"frame_{int(frame):02d}.png")

# Cleanup - close all devices
if 'scope' in locals():
    scope.close()
    print("Disconnected scope")

# Close DeviceManager
if 'device_manager' in locals():
    device_manager.close()
    print("DeviceManager closed")
```

## Key Improvements

1. ✅ **No variable initialization to None**
2. ✅ **Cleaner OPC pattern for tm_devices**
3. ✅ **Proper acquisition + OPC combination**
4. ✅ **Type hints only when explicitly requested**
5. ✅ **Proper cleanup (already working)**
6. ✅ **Cleaner code structure**

## Remaining Issues

1. ✅ **XML Loop Mutation**: Fixed in Custom GPT instructions - `controls_for` blocks MUST include `<mutation><variable>var_name</variable></mutation>`. Without it:
   - Blockly UI may misbehave
   - Variable scoping can break
   - Round-trip XML import/export is unstable
   
2. ⚠️ **OPC Limitation**: Current tm_devices OPC pattern uses `scope.commands.opc.query()` which:
   - Guarantees command queue completion (not necessarily acquisition completion)
   - Works for FastFrame and single sequence acquisitions in most cases
   - Is a fallback - acquisition lifecycle should ideally be block-driven
   - TODO: Consider implementing acquisition-specific completion detection in the future

## Recommendations

1. **Update Custom GPT Instructions**: Add explicit example showing loop mutation structure
2. **Consider OPC Timeout**: For tm_devices, could add timeout handling if needed
3. **Test Generated Code**: Verify all fixes work correctly with real instruments
