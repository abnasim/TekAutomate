import { Article, Category } from '../components/Academy/types';

// Helper function to create content blocks
const heading = (level: number, text: string) => ({ type: 'heading' as const, level, text });
const paragraph = (text: string) => ({ type: 'paragraph' as const, text });
const code = (language: string, codeText: string) => ({ type: 'code' as const, language, code: codeText });
const table = (headers: string[], rows: string[][]) => ({ 
  type: 'table' as const, 
  data: { headers, rows } 
});
const callout = (variant: 'info' | 'warning' | 'tip' | 'error', title: string, text: string) => ({
  type: 'callout' as const,
  variant,
  title,
  text,
});

// Articles
export const articles: Article[] = [
  // ========== SECTION 1: CONNECTION & HARDWARE ==========
  
  // 1.1 Physical Connectivity
  {
    id: 'ethernet_vs_usb_vs_gpib',
    title: 'Ethernet vs. USB vs. GPIB: The Hierarchy of Automation Reliability',
    category: 'connection_hardware',
    subcategory: 'physical_connectivity',
    content: [
      heading(2, 'Why Ethernet is King'),
      paragraph('When automating test equipment, your connection method determines reliability, speed, and ease of use. Here\'s why Ethernet should be your first choice:'),
      paragraph('Ethernet provides galvanic isolation between your PC and the instrument. This means electrical noise, ground loops, and potential differences won\'t corrupt your measurements. USB and GPIB lack this protection.'),
      paragraph('Ethernet also allows for much longer cable runs (up to 100 meters) compared to USB (5 meters) or GPIB (20 meters with extenders). This is crucial in lab environments where instruments are spread out.'),
      callout('tip', 'No Drivers Required', 'Ethernet connections use standard TCP/IP protocols. No vendor-specific drivers needed—just an IP address and you\'re connected. USB requires driver installation and can conflict with other devices.'),
      heading(3, 'Connection Reliability Ranking'),
      paragraph('1. Ethernet (TCP/IP) - Most reliable, driverless, long distance'),
      paragraph('2. USB - Convenient but requires drivers, limited distance'),
      paragraph('3. GPIB (IEEE-488) - Legacy standard, requires interface card, limited distance'),
    ],
    relatedArticles: ['direct_pc_to_scope', 'finding_ip_address'],
  },
  
  {
    id: 'direct_pc_to_scope',
    title: 'Direct PC-to-Scope Connection: Setting Static IPs',
    category: 'connection_hardware',
    subcategory: 'physical_connectivity',
    content: [
      heading(2, 'When You Don\'t Have a Network Switch'),
      paragraph('If you don\'t have a network switch or router, you can connect your PC directly to the oscilloscope using an Ethernet cable. This requires setting static IP addresses on both devices.'),
      heading(3, 'Step 1: Configure the Oscilloscope'),
      paragraph('1. Navigate to Utility → I/O → Network'),
      paragraph('2. Set the IP address to a static value (e.g., 192.168.1.100)'),
      paragraph('3. Set Subnet Mask to 255.255.255.0'),
      paragraph('4. Disable DHCP/Auto IP'),
      heading(3, 'Step 2: Configure Your PC'),
      paragraph('1. Open Network Settings (Windows: Settings → Network & Internet)'),
      paragraph('2. Find your Ethernet adapter'),
      paragraph('3. Set IP address to 192.168.1.101 (same subnet, different address)'),
      paragraph('4. Set Subnet Mask to 255.255.255.0'),
      paragraph('5. Leave Default Gateway empty'),
      callout('warning', 'Important', 'Both devices must be on the same subnet (192.168.1.x) but have different IP addresses.'),
    ],
    relatedArticles: ['finding_ip_address', 'lxi_web_interface'],
  },
  
  {
    id: 'finding_ip_address',
    title: 'How to Find Your Instrument IP Address',
    category: 'connection_hardware',
    subcategory: 'physical_connectivity',
    content: [
      heading(2, 'MSO 4/5/6/7 Series'),
      paragraph('1. Press the Utility button on the front panel'),
      paragraph('2. Navigate to I/O → Network'),
      paragraph('3. The IP address is displayed on the screen'),
      paragraph('4. If using DHCP, the address may change. Consider setting a static IP.'),
      heading(2, 'DPO7000 Series'),
      paragraph('1. Press Utility → I/O'),
      paragraph('2. Select Network Settings'),
      paragraph('3. View the current IP address'),
      heading(2, 'MDO3000 Series'),
      paragraph('1. Press Utility → I/O'),
      paragraph('2. Select Network'),
      paragraph('3. The IP address is shown in the network configuration'),
      heading(2, 'Generic Windows-Based Scopes'),
      paragraph('Many Tektronix scopes run Windows. You can:'),
      paragraph('1. Use the front panel menu (same as above)'),
      paragraph('2. Or connect a keyboard/mouse and check Network Settings in Windows'),
      paragraph('3. Or use the LXI Web Interface (see related article)'),
      callout('tip', 'Pro Tip', 'If the scope is on a network, you can also find it using the LXI Discovery tool or by checking your router\'s connected devices list.'),
    ],
    relatedArticles: ['lxi_web_interface', 'ethernet_vs_usb_vs_gpib'],
  },
  
  {
    id: 'lxi_web_interface',
    title: 'LXI Web Interface: The "Ping Test"',
    category: 'connection_hardware',
    subcategory: 'physical_connectivity',
    content: [
      heading(2, 'Verify Your Instrument is Alive'),
      paragraph('The simplest way to verify your oscilloscope is connected and responding is to open its IP address in a web browser. This is called the LXI (LAN eXtensions for Instrumentation) Web Interface.'),
      heading(3, 'How to Access'),
      paragraph('1. Make sure your PC and scope are on the same network'),
      paragraph('2. Open any web browser (Chrome, Firefox, Edge)'),
      paragraph('3. Type the scope\'s IP address in the address bar (e.g., http://192.168.1.55)'),
      paragraph('4. Press Enter'),
      heading(3, 'What You Should See'),
      paragraph('If the connection is working, you\'ll see the instrument\'s web interface showing:'),
      paragraph('- Instrument model and serial number'),
      paragraph('- Current settings and measurements'),
      paragraph('- Network configuration'),
      paragraph('- System information'),
      callout('info', 'Troubleshooting', 'If the page doesn\'t load, check:'),
      paragraph('• Is the IP address correct?'),
      paragraph('• Are both devices on the same network?'),
      paragraph('• Is the scope\'s web server enabled? (Check Utility → I/O → Network)'),
      paragraph('• Is a firewall blocking the connection?'),
    ],
    relatedArticles: ['finding_ip_address', 'error_rsrc_nfound'],
  },
  
  // 1.2 The VISA Protocol
  {
    id: 'visa_resource_explained',
    title: 'What is a VISA Resource String?',
    category: 'connection_hardware',
    subcategory: 'visa_protocol',
    content: [
      heading(2, 'Anatomy of a Resource String'),
      paragraph('A VISA resource string tells your software how to connect to an instrument. Let\'s break down an example:'),
      code('text', 'TCPIP0::192.168.1.50::inst0::INSTR'),
      heading(3, 'Breaking It Down'),
      paragraph('TCPIP0 - The interface type and instance number:'),
      paragraph('  • TCPIP = Ethernet connection'),
      paragraph('  • 0 = First TCP/IP interface (if you have multiple)'),
      paragraph(''),
      paragraph('192.168.1.50 - The IP address of your instrument'),
      paragraph(''),
      paragraph('inst0 - The instrument instance (usually 0 for the first instrument)'),
      paragraph(''),
      paragraph('INSTR - The resource class (INSTR = Instrument Protocol, uses VXI-11)'),
      heading(3, 'Other Common Formats'),
      code('text', 'TCPIP::192.168.1.50::5025::SOCKET  // Raw socket on port 5025'),
      code('text', 'USB0::0x0699::0x0522::C012345::INSTR  // USB connection'),
      code('text', 'GPIB0::5::INSTR  // GPIB at address 5'),
      callout('tip', 'Default Ports', 'When using TCPIP::...::INSTR, VISA uses port 1024 (VXI-11) by default. For raw sockets, port 4000 or 5025 is common on Tektronix instruments.'),
    ],
    faqs: [
      {
        question: 'Why is my connection timing out?',
        answer: 'Common causes: wrong IP address, firewall blocking the port, instrument not powered on, or network cable disconnected. Check the IP with the LXI web interface first.',
      },
      {
        question: 'Can I use USB instead?',
        answer: 'Yes, but USB requires driver installation (Tektronix USB drivers). Ethernet is driverless and more reliable for automation. USB is fine for occasional use, but Ethernet is recommended for automated testing.',
      },
    ],
    relatedArticles: ['vxi11_vs_sockets', 'termination_characters', 'error_tmo'],
  },
  
  {
    id: 'vxi11_vs_sockets',
    title: 'VXI-11 vs. Sockets: Understanding the Difference',
    category: 'connection_hardware',
    subcategory: 'visa_protocol',
    content: [
      heading(2, 'Three Ways to Talk Over Ethernet'),
      paragraph('When connecting to an instrument over Ethernet, you have three protocol options: VXI-11 (via PyVISA), VXI-11 (standalone), and raw sockets.'),
      heading(3, 'VXI-11 via PyVISA (The Standard Way)'),
      paragraph('When you use a resource string like TCPIP::192.168.1.50::INSTR with PyVISA, PyVISA automatically uses VXI-11 under the hood. This is the most common approach.'),
      paragraph('Advantages:'),
      paragraph('• Handles message boundaries automatically'),
      paragraph('• Reliable error handling'),
      paragraph('• Works with most instruments out of the box'),
      paragraph('• No need to worry about termination characters'),
      paragraph('• Industry standard (VISA API)'),
      code('python', '# VXI-11 via PyVISA (default)\nimport pyvisa\nrm = pyvisa.ResourceManager()\nscope = rm.open_resource("TCPIP::192.168.1.50::INSTR")\n# PyVISA uses VXI-11 automatically when you use ::INSTR\nscope.write("*IDN?")  # No \\n needed!\nprint(scope.read())'),
      heading(3, 'VXI-11 Standalone (The Lightweight Way)'),
      paragraph('You can also use VXI-11 directly without PyVISA using the python-vxi11 package. This is useful when you want to avoid VISA dependencies.'),
      paragraph('Advantages:'),
      paragraph('• No VISA installation required'),
      paragraph('• Lighter weight (just one package)'),
      paragraph('• Still uses VXI-11 protocol (reliable)'),
      paragraph('• Good for Linux environments'),
      paragraph('Disadvantages:'),
      paragraph('• Less common (most people use PyVISA)'),
      paragraph('• Different API (not VISA-compatible)'),
      code('python', '# VXI-11 standalone (python-vxi11 package)\nimport vxi11\ninstrument = vxi11.Instrument("192.168.1.50")\nidn = instrument.ask("*IDN?")  # ask() = write + read\nprint(idn)\ninstrument.write(":CH1:SCAle 0.5")\ninstrument.close()'),
      callout('info', 'PyVISA vs. Standalone VXI-11', 'Both use the same VXI-11 protocol! PyVISA is a wrapper that uses VXI-11 when you specify ::INSTR. The standalone vxi11 package talks VXI-11 directly.'),
      heading(3, 'Raw Sockets (The Direct Way)'),
      paragraph('Raw sockets give you direct TCP/IP access without any protocol layer. You must specify a port number and handle termination yourself.'),
      paragraph('Advantages:'),
      paragraph('• Slightly faster (less protocol overhead)'),
      paragraph('• More control over the connection'),
      paragraph('• Can be useful for debugging'),
      paragraph('• No VISA or VXI-11 dependencies'),
      paragraph('Disadvantages:'),
      paragraph('• You must add \\n (line feed) to every command'),
      paragraph('• Must handle message boundaries manually'),
      paragraph('• More error-prone'),
      paragraph('• No automatic error handling'),
      code('python', '# Raw socket connection (direct TCP/IP)\nimport socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect(("192.168.1.50", 5025))  # Port 5025 for SCPI\nsock.send(b"*IDN?\\n")  # Must include \\n!\ndata = sock.recv(4096)\nprint(data.decode())\nsock.close()'),
      callout('warning', 'Termination Required', 'With raw sockets, forgetting the \\n character is the #1 cause of timeouts. Always append \\n to your commands.'),
      heading(3, 'Which Should You Use?'),
      paragraph('• PyVISA (VXI-11): Use for most automation - industry standard, reliable, well-supported'),
      paragraph('• Standalone VXI-11: Use when you want to avoid VISA dependencies or need a lightweight solution'),
      paragraph('• Raw Sockets: Use only when you need maximum control or are debugging connection issues'),
    ],
    relatedArticles: ['termination_characters', 'port_numbers', 'visa_resource_explained', 'pyvisa_deep_dive'],
  },
  
  {
    id: 'port_numbers',
    title: 'Port Numbers: Why Port 4000?',
    category: 'connection_hardware',
    subcategory: 'visa_protocol',
    content: [
      heading(2, 'Common Ports for Tektronix Instruments'),
      paragraph('Port 4000 is often used for raw socket connections on Tektronix oscilloscopes. Here\'s why:'),
      paragraph('• Port 4000 is the default SCPI socket port for many Tektronix instruments'),
      paragraph('• It\'s in the "unprivileged" range (above 1024), so no admin rights needed'),
      paragraph('• It\'s less likely to conflict with other services'),
      heading(3, 'Other Common Ports'),
      paragraph('• Port 1024 - VXI-11 default (used automatically with TCPIP::...::INSTR)'),
      paragraph('• Port 5025 - Alternative SCPI socket port (some newer instruments)'),
      paragraph('• Port 80 - HTTP (for LXI web interface)'),
      paragraph('• Port 443 - HTTPS (secure web interface, if enabled)'),
      code('text', '# Using port 4000 for raw socket\nTCPIP::192.168.1.50::4000::SOCKET'),
      callout('tip', 'Finding the Right Port', 'Check your instrument\'s documentation or use the LXI web interface to see which ports are enabled. Most modern Tektronix scopes support both 4000 and 5025.'),
    ],
    relatedArticles: ['vxi11_vs_sockets', 'visa_resource_explained'],
  },
  
  {
    id: 'termination_characters',
    title: 'Termination Characters: Why \\n Matters',
    category: 'connection_hardware',
    subcategory: 'visa_protocol',
    content: [
      heading(2, 'The #1 Cause of Timeouts'),
      paragraph('Forgetting to add a termination character (\\n, line feed) is the most common cause of connection timeouts when using raw sockets.'),
      heading(3, 'Why Termination is Needed'),
      paragraph('SCPI commands are line-based. The instrument needs to know when a command ends. The newline character (\\n) signals "end of command."'),
      paragraph('Without it, the instrument waits forever for the rest of the command, and your script times out.'),
      code('python', '# WRONG - Missing \\n\nsock.send(b"*IDN?")  # Instrument waits... timeout!\n\n# CORRECT - With \\n\nsock.send(b"*IDN?\\n")  # Instrument responds immediately'),
      heading(3, 'VXI-11 vs. Raw Sockets'),
      paragraph('With VXI-11 (TCPIP::...::INSTR), VISA handles termination automatically:'),
      code('python', '# VXI-11 - No \\n needed\nscope = rm.open_resource("TCPIP::192.168.1.50::INSTR")\nscope.write("*IDN?")  # VISA adds termination automatically'),
      paragraph('With raw sockets, you must add it yourself:'),
      code('python', '# Raw socket - \\n required\nsock.send(b"*IDN?\\n")  # You must add \\n'),
      callout('error', 'Common Mistake', 'If you\'re getting timeouts with raw sockets, check that every command ends with \\n. This is the #1 debugging step.'),
    ],
    relatedArticles: ['vxi11_vs_sockets', 'error_tmo', 'visa_resource_explained'],
  },
  
  // 1.3 Instrument-Specific Quirks
  {
    id: 'mso_456_permissions',
    title: 'MSO 4/5/6/7 Series: User Account vs. Automation Permissions',
    category: 'connection_hardware',
    subcategory: 'instrument_quirks',
    content: [
      heading(2, 'The Permission Problem'),
      paragraph('MSO 4/5/6/7 Series oscilloscopes run Windows and have user account controls. Some operations require "Automation" permissions rather than "User" permissions.'),
      heading(3, 'What\'s the Difference?'),
      paragraph('User Account: Limited permissions, can\'t modify certain system settings'),
      paragraph('Automation Account: Full permissions for remote control and automation'),
      heading(3, 'How to Enable Automation Mode'),
      paragraph('1. On the scope, press Utility → System → Security'),
      paragraph('2. Enable "Automation Account" or "Remote Control"'),
      paragraph('3. You may need to set a password'),
      paragraph('4. Some scopes require a reboot after enabling'),
      callout('warning', 'Security Note', 'Automation mode gives full control to remote connections. Only enable it in secure lab environments, not on production networks.'),
      heading(3, 'Common Issues'),
      paragraph('• Commands work locally but fail remotely → Check automation permissions'),
      paragraph('• File operations fail → May need automation account'),
      paragraph('• Settings don\'t persist → User account limitations'),
    ],
    relatedArticles: ['error_rsrc_nfound', 'settings_not_applying'],
  },
  
  {
    id: 'dpo_mso_legacy',
    title: 'Older DPO/MSO Scopes: Talk/Listen Mode',
    category: 'connection_hardware',
    subcategory: 'instrument_quirks',
    content: [
      heading(2, 'Legacy Instrument Quirks'),
      paragraph('Older DPO and MSO series oscilloscopes (pre-2010) sometimes require manual enabling of "Talk/Listen" mode for remote control.'),
      heading(3, 'How to Enable'),
      paragraph('1. Press Utility → I/O'),
      paragraph('2. Look for "Remote" or "Talk/Listen" option'),
      paragraph('3. Enable remote control'),
      paragraph('4. Some models require this to be set each power cycle'),
      callout('info', 'Modern Instruments', 'MSO 4/5/6/7 and newer series don\'t require this—remote control is enabled by default when connected via Ethernet.'),
    ],
    relatedArticles: ['mso_456_permissions', 'error_rsrc_nfound'],
  },
  
  {
    id: 'keithley_smu_connection',
    title: 'Keithley SMUs: GPIB Legacy vs. Modern LAN',
    category: 'connection_hardware',
    subcategory: 'instrument_quirks',
    content: [
      heading(2, 'Connection Differences'),
      paragraph('Keithley Source Measure Units (SMUs) have evolved from GPIB-only to modern LAN-capable instruments.'),
      heading(3, 'Older Models (GPIB Only)'),
      paragraph('• Require GPIB interface card in PC'),
      paragraph('• Use resource string: GPIB0::12::INSTR'),
      paragraph('• Limited to 20 meters cable length'),
      paragraph('• Requires NI-488.2 or similar drivers'),
      heading(3, 'Modern Models (LAN Capable)'),
      paragraph('• Support Ethernet connections'),
      paragraph('• Use resource string: TCPIP::192.168.1.50::INSTR'),
      paragraph('• Same reliability as Tektronix scopes'),
      paragraph('• Driverless connection'),
      callout('tip', 'Check Your Model', 'Most Keithley SMUs from 2010 onwards support LAN. Check the instrument\'s network settings menu to confirm.'),
    ],
    relatedArticles: ['ethernet_vs_usb_vs_gpib', 'visa_resource_explained'],
  },
  
  // ========== SECTION 2: THE ENGINE ROOM ==========
  
  // 2.1 Driver Deep Dives
  {
    id: 'pyvisa_deep_dive',
    title: 'PyVISA Deep Dive: The Industry Standard',
    category: 'engine_room',
    subcategory: 'driver_deep_dives',
    content: [
      heading(2, 'What is PyVISA?'),
      paragraph('PyVISA is a Python wrapper around VISA (Virtual Instrument Software Architecture). It provides a uniform API for controlling instruments regardless of connection type (Ethernet, USB, GPIB).'),
      heading(3, 'How PyVISA Uses VXI-11'),
      paragraph('When you connect to an instrument over Ethernet using a resource string like TCPIP::192.168.1.50::INSTR, PyVISA automatically uses the VXI-11 protocol under the hood. The ::INSTR suffix tells PyVISA to use VXI-11 (Instrument Protocol) instead of raw sockets.'),
      paragraph('This means:'),
      paragraph('• PyVISA handles VXI-11 automatically - you don\'t need to configure it'),
      paragraph('• VXI-11 provides reliable message boundaries and error handling'),
      paragraph('• You get the benefits of VXI-11 without writing VXI-11 code directly'),
      paragraph('• PyVISA abstracts away the protocol details'),
      code('python', 'import pyvisa\n\n# When you use ::INSTR, PyVISA uses VXI-11 automatically\nrm = pyvisa.ResourceManager()\nscope = rm.open_resource("TCPIP::192.168.1.50::INSTR")\n# ↑ This resource string tells PyVISA to use VXI-11\n# PyVISA handles all VXI-11 protocol details for you\n\nscope.write("*IDN?")  # No \\n needed - VXI-11 handles it\nidn = scope.read()\nprint(f"Connected: {idn}")'),
      callout('info', 'VXI-11 vs. Standalone', 'PyVISA uses VXI-11 when you specify ::INSTR. You can also use VXI-11 directly with the python-vxi11 package (see "VXI-11 vs. Sockets" article), but PyVISA is the standard way.'),
      heading(3, 'Installation'),
      code('bash', 'pip install pyvisa pyvisa-py'),
      paragraph('Note: You can use either NI-VISA (requires National Instruments drivers) or pyvisa-py (pure Python, no drivers needed). Both support VXI-11 for Ethernet connections.'),
      heading(3, 'Basic Usage'),
      code('python', 'import pyvisa\n\n# Create resource manager\nrm = pyvisa.ResourceManager()\n\n# Open connection (uses VXI-11 automatically)\nscope = rm.open_resource("TCPIP::192.168.1.50::INSTR")\nscope.timeout = 5000  # 5 second timeout\n\n# Send commands (VXI-11 handles termination)\nscope.write("*RST")  # Reset\nscope.write(":CH1:SCAle 0.5")  # Set channel 1 scale\n\n# Query responses\nidn = scope.query("*IDN?")  # Identify\nprint(f"Connected to: {idn}")\n\n# Close connection\nscope.close()'),
      heading(3, 'Connection Types in PyVISA'),
      paragraph('PyVISA supports multiple connection types:'),
      paragraph('• TCPIP::...::INSTR - Ethernet via VXI-11 (most common)'),
      paragraph('• TCPIP::...::SOCKET - Raw socket (requires manual termination)'),
      paragraph('• USB::...::INSTR - USB connection'),
      paragraph('• GPIB0::...::INSTR - GPIB connection'),
      code('python', '# VXI-11 (automatic termination)\nscope = rm.open_resource("TCPIP::192.168.1.50::INSTR")\nscope.write("*IDN?")  # No \\n needed\n\n# Raw socket (manual termination required)\nscope = rm.open_resource("TCPIP::192.168.1.50::5025::SOCKET")\nscope.write_termination = "\\n"  # Must set manually!\nscope.read_termination = "\\n"\nscope.write("*IDN?")  # Now works correctly'),
      heading(3, 'Pros'),
      paragraph('• Universal compatibility (works with all instruments)'),
      paragraph('• Industry standard, well-documented'),
      paragraph('• Large community and examples'),
      paragraph('• Works with any VISA backend (NI, Keysight, etc.)'),
      paragraph('• Automatic VXI-11 support (no configuration needed)'),
      paragraph('• Handles protocol details (termination, message boundaries)'),
      heading(3, 'Cons'),
      paragraph('• Requires SCPI knowledge (string-based commands)'),
      paragraph('• No auto-completion or type checking'),
      paragraph('• Slower than native drivers for some operations'),
      paragraph('• Error-prone (typos in command strings)'),
      callout('tip', 'Best For', 'PyVISA is best for: generic automation, multi-vendor setups, simple scripts, and when you need maximum compatibility. The automatic VXI-11 support makes it ideal for Ethernet connections.'),
    ],
    relatedArticles: ['backend_comparison', 'tm_devices_deep_dive', 'nivisa_vs_pyvisa_py', 'vxi11_vs_sockets'],
  },
  
  {
    id: 'tm_devices_deep_dive',
    title: 'tm_devices Deep Dive: The Modern Way',
    category: 'engine_room',
    subcategory: 'driver_deep_dives',
    content: [
      heading(2, 'What is tm_devices?'),
      paragraph('tm_devices is Tektronix\'s official Python library for controlling Tektronix instruments. It provides object-oriented, context-aware APIs with auto-completion and type safety. Unlike PyVISA which uses generic SCPI strings, tm_devices exposes device-specific commands based on your equipment model.'),
      callout('info', 'Device-Specific APIs', 'tm_devices automatically detects your instrument model and exposes the appropriate Python API. A 6 Series MSO has different methods than a 2 Series MSO, and tm_devices knows the difference!'),
      heading(3, 'Installation'),
      code('bash', 'pip install tm-devices'),
      heading(3, 'Dependencies: Works Out of the Box'),
      paragraph('tm_devices can be used without any external (non-Python) dependencies on any operating system thanks to the PyVISA-py VISA backend. However, if you install a third-party VISA backend such as TekVISA (>=4.2.0) or NI-VISA, tm_devices will automatically use it for better performance and additional features.'),
      paragraph('tm_devices will:'),
      paragraph('• Use TekVISA or NI-VISA if installed (better performance)'),
      paragraph('• Fall back to PyVISA-py if no other VISA backends are found (works everywhere)'),
      paragraph('• Work on Windows, Linux, and macOS without any drivers'),
      callout('tip', 'No Driver Hassle', 'Unlike PyVISA with NI-VISA, tm_devices works immediately after pip install. No need to download and install VISA drivers unless you want the extra features.'),
      heading(3, 'Basic Usage'),
      code('python', 'from tm_devices import DeviceManager\n\n# DeviceManager handles connection cleanup automatically\nwith DeviceManager() as dm:\n    # Connect to scope (auto-detects model)\n    scope = dm.add_scope("192.168.1.50")\n    \n    # Object-oriented API with auto-completion\n    scope.reset()  # Instead of scope.write("*RST")\n    scope.ch[1].scale = 0.5  # Instead of ":CH1:SCAle 0.5"\n    \n    # Device-specific methods (varies by model)\n    # 6 Series MSO has different API than 2 Series MSO\n    scope.ch[1].turn_on()  # Model-specific method\n    \n    # Still supports raw SCPI when needed\n    idn = scope.query("*IDN?")  # Fallback to SCPI\n    print(f"Connected to: {idn}")'),
      heading(3, 'The DeviceManager Advantage'),
      paragraph('DeviceManager automatically handles:'),
      paragraph('• Connection cleanup (closes on exit)'),
      paragraph('• Error recovery'),
      paragraph('• Resource management'),
      paragraph('• Multi-device coordination'),
      paragraph('• Automatic device detection and driver selection'),
      heading(3, 'Massive Tektronix Compatibility'),
      paragraph('tm_devices supports virtually all modern Tektronix instruments, including the latest 7 Series DPO:'),
      table(
        ['Category', 'Series/Models', 'Status'],
        [
          ['Oscilloscopes', '1 Series, 2 Series MSO, 3 Series MDO, 4 Series MSO, 4 Series B MSO, 5 Series MSO, 5 Series B MSO, 5 Series MSO (LP), 6 Series MSO, 6 Series B MSO, 6 Series LPD', '✅ Full Support'],
          ['Oscilloscopes', '7 Series DPO ⭐ NEW ⭐', '✅ Full Support'],
          ['Oscilloscopes', 'MSO2000/B, DPO2000/B, MDO3000, MDO4000/B/C, MSO4000/B, DPO4000/B, MSO5000/B, DPO5000/B', '✅ Full Support'],
          ['Oscilloscopes', 'DPO7000/C, DPO70000/C/D/DX/SX, DSA70000/C/D, MSO70000/C/DX', '✅ Full Support'],
          ['Arbitrary Function Generators', 'AFG3000, AFG31xxx', '✅ Full Support'],
          ['Arbitrary Waveform Generators', 'AWG5000, AWG5200, AWG7000, AWG70000', '✅ Full Support'],
          ['Power Supplies', '2200, 2220, 2230, 2231, 2280S, 2281S', '✅ Full Support'],
          ['Source Measure Units', '24xx Standard, 24xx Interactive, 26xxB, 2636B, 2601B-PULSE, 2606B, 2651A, 2657A', '✅ Full Support'],
          ['Electrometers', '6430, 6514, 6517B', '✅ Full Support'],
          ['Digital Multimeters', 'DMM6500, DMM7510, DMM7512', '✅ Full Support'],
          ['Data Acquisition', 'DAQ6510', '✅ Full Support'],
          ['Switch Systems', '3706A', '✅ Full Support'],
          ['Modular Test Systems', 'TMT4', '✅ Full Support'],
          ['Modular Power Systems', 'MP5000 Series ⭐ NEW ⭐', '✅ Full Support'],
        ]
      ),
      callout('tip', 'Latest Addition', 'The 7 Series DPO is the newest addition to tm_devices support! This represents Tektronix\'s latest and greatest oscilloscope technology with full Python API support.'),
      heading(3, 'Device-Specific Command Exposure'),
      paragraph('The biggest advantage of tm_devices is that it exposes commands based on your specific equipment:'),
      paragraph('• 6 Series MSO: Has methods for advanced triggering, serial decode, and protocol analysis'),
      paragraph('• 2 Series MSO: Simpler API focused on basic measurements'),
      paragraph('• AWG70000: Methods for waveform generation and sequencing'),
      paragraph('• SMU 26xxB: Methods for source-measure operations'),
      paragraph('Each device type has its own Python API that matches its capabilities. No more guessing which SCPI commands work!'),
      code('python', '# Example: Device-specific APIs\nfrom tm_devices import DeviceManager\n\nwith DeviceManager() as dm:\n    # 6 Series MSO - advanced features\n    scope6 = dm.add_scope("192.168.1.50")  # Detected as 6 Series\n    scope6.ch[1].turn_on()\n    scope6.ch[1].scale = 0.5\n    # 6 Series has protocol decode methods\n    scope6.serial.decode.enable = True\n    \n    # 2 Series MSO - simpler API\n    scope2 = dm.add_scope("192.168.1.51")  # Detected as 2 Series\n    scope2.ch[1].turn_on()\n    scope2.ch[1].scale = 0.5\n    # 2 Series doesn\'t have protocol decode\n    # scope2.serial.decode  # This would error - not available!'),
      heading(3, 'Pros'),
      paragraph('• Object-oriented, Pythonic API'),
      paragraph('• Auto-completion in IDEs (knows your device capabilities)'),
      paragraph('• Type checking and validation'),
      paragraph('• Context-aware (automatic cleanup)'),
      paragraph('• Device-specific command exposure'),
      paragraph('• Massive Tektronix hardware compatibility'),
      paragraph('• Works without external dependencies (PyVISA-py fallback)'),
      paragraph('• Still supports raw SCPI when needed'),
      heading(3, 'Cons'),
      paragraph('• Tektronix-only (not for other vendors)'),
      paragraph('• Heavier installation (more dependencies)'),
      paragraph('• Steeper learning curve initially'),
      paragraph('• Device-specific APIs mean you need to know your model'),
      callout('tip', 'Best For', 'tm_devices is best for: Tektronix-only setups, robust production scripts, when you want IDE support, device-specific APIs, and object-oriented code. Perfect if you\'re working with modern Tektronix equipment (especially 1-7 Series oscilloscopes).'),
    ],
    relatedArticles: ['backend_comparison', 'hybrid_mode_explained', 'pyvisa_deep_dive'],
  },
  
  {
    id: 'tekhsi_deep_dive',
    title: 'TekHSI Deep Dive: The Speed Demon',
    category: 'engine_room',
    subcategory: 'driver_deep_dives',
    content: [
      heading(2, 'What is TekHSI?'),
      paragraph('TekHSI (Tektronix High-Speed Interface) is a protocol buffer/gRPC-based data tunnel designed for ultra-fast waveform acquisition. It can be 10x faster than traditional SCPI for large data transfers.'),
      heading(3, 'Speed Comparison'),
      paragraph('Transfer speed for 10M point waveform:'),
      paragraph('• PyVISA (SCPI): ~2-5 MB/s'),
      paragraph('• tm_devices: ~3-6 MB/s'),
      paragraph('• TekHSI: ~20-50 MB/s (10x faster!)'),
      heading(3, 'Constraints'),
      paragraph('• Only works on Windows and Linux (not macOS)'),
      paragraph('• Requires specific scope firmware (MSO 4/5/6/7 Series, firmware 1.0.0 or later)'),
      paragraph('• Requires SFP+ port on scope (for 10 Gbps connection)'),
      paragraph('• More complex setup (requires TekHSI Python package)'),
      heading(3, 'When to Use'),
      paragraph('Use TekHSI when:'),
      paragraph('• You need maximum waveform transfer speed'),
      paragraph('• You\'re acquiring large datasets repeatedly'),
      paragraph('• Transfer time is a bottleneck in your workflow'),
      paragraph('• You have MSO 4/5/6/7 Series with SFP+ port'),
      code('python', 'from tekhsi import TekHSIConnect\n\n# Connect via TekHSI\nwith TekHSIConnect("192.168.1.50") as hsi:\n    # Ultra-fast waveform acquisition\n    waveform = hsi.acquire_waveform(channel=1, points=10000000)\n    # 10M points in seconds, not minutes!'),
      callout('warning', 'Not for Everything', 'TekHSI is optimized for data transfer, not control. Use it for waveform acquisition, but use PyVISA or tm_devices for setting knobs and configurations.'),
    ],
    relatedArticles: ['backend_comparison', 'hybrid_mode_explained', 'binary_vs_ascii'],
  },
  
  // 2.2 Comparison Guides
  {
    id: 'backend_comparison',
    title: 'Choosing the Right Engine: PyVISA vs. tm_devices vs. TekHSI',
    category: 'engine_room',
    subcategory: 'comparison_guides',
    content: [
      heading(2, 'Decision Tree'),
      paragraph('Which backend should you use? Follow this decision tree:'),
      paragraph('1. Are you only using Tektronix instruments?'),
      paragraph('   → Yes: Consider tm_devices for better developer experience'),
      paragraph('   → No: Use PyVISA (works with all vendors)'),
      paragraph(''),
      paragraph('2. Do you need maximum waveform transfer speed?'),
      paragraph('   → Yes: Use TekHSI (if scope supports it) or Hybrid Mode'),
      paragraph('   → No: PyVISA or tm_devices is fine'),
      paragraph(''),
      paragraph('3. Do you want IDE auto-completion and type safety?'),
      paragraph('   → Yes: Use tm_devices'),
      paragraph('   → No: PyVISA is simpler'),
      heading(3, 'Comparison Table'),
      table(
        ['Feature', 'PyVISA', 'tm_devices', 'TekHSI'],
        [
          ['Compatibility', 'All vendors', 'Tektronix only', 'MSO 4/5/6/7 only'],
          ['Speed', 'Standard', 'Standard', '10x faster'],
          ['Auto-completion', 'No', 'Yes', 'No'],
          ['Type Safety', 'No', 'Yes', 'No'],
          ['Learning Curve', 'Medium', 'Easy', 'Easy'],
          ['Installation', 'Simple', 'Easy', 'Easy'],
          ['Best For', 'Generic automation', 'Production scripts', 'High-speed data'],
        ]
      ),
      heading(3, 'Use Cases'),
      paragraph('PyVISA:'),
      paragraph('• Multi-vendor test setups'),
      paragraph('• Simple automation scripts'),
      paragraph('• Learning SCPI'),
      paragraph('• Maximum compatibility'),
      paragraph(''),
      paragraph('tm_devices:'),
      paragraph('• Tektronix-only automation'),
      paragraph('• Production-grade scripts'),
      paragraph('• When you want IDE support'),
      paragraph('• Object-oriented code'),
      paragraph(''),
      paragraph('TekHSI:'),
      paragraph('• High-speed waveform acquisition'),
      paragraph('• Large dataset collection'),
      paragraph('• When transfer speed is critical'),
      paragraph('• MSO 4/5/6/7 Series with SFP+'),
      callout('tip', 'Hybrid Mode', 'You can use multiple backends together! Use PyVISA for control and TekHSI for data. See the "Hybrid Mode Explained" article.'),
    ],
    faqs: [
      {
        question: 'Which backend is fastest?',
        answer: 'TekHSI is fastest for data transfer (10x faster), but PyVISA and tm_devices are similar for control operations. For most use cases, the difference is negligible unless you\'re transferring huge waveforms.',
      },
      {
        question: 'Can I switch backends later?',
        answer: 'Yes! The generated scripts are modular. You can change the backend and regenerate. However, TekHSI requires specific hardware, so switching to it may not always be possible.',
      },
    ],
    relatedArticles: ['hybrid_mode_explained', 'pyvisa_deep_dive', 'tm_devices_deep_dive', 'tekhsi_deep_dive'],
  },
  
  {
    id: 'hybrid_mode_explained',
    title: 'What is Hybrid Mode?',
    category: 'engine_room',
    subcategory: 'comparison_guides',
    content: [
      heading(2, 'Control Plane vs. Data Plane'),
      paragraph('Hybrid Mode is the architecture of using different backends for different tasks:'),
      paragraph('• Control Plane: Use PyVISA or tm_devices for setting knobs, configurations, and simple queries'),
      paragraph('• Data Plane: Use TekHSI for high-speed waveform acquisition'),
      heading(3, 'Why Separate Them?'),
      paragraph('Control operations (setting scales, triggers, etc.) don\'t need speed—they need reliability and compatibility. Data operations (acquiring waveforms) need speed.'),
      paragraph('By using the right tool for each job, you get:'),
      paragraph('• Reliable control (PyVISA/tm_devices)'),
      paragraph('• Fast data transfer (TekHSI)'),
      paragraph('• Best of both worlds'),
      code('python', '# Hybrid Mode Example\nimport pyvisa\nfrom tekhsi import TekHSIConnect\n\n# Control via PyVISA\nrm = pyvisa.ResourceManager()\nscope = rm.open_resource("TCPIP::192.168.1.50::INSTR")\nscope.write(":CH1:SCAle 0.5")  # Set scale\nscope.write(":TRIGger:TYPe EDGE")  # Set trigger\n\n# Data via TekHSI\nwith TekHSIConnect("192.168.1.50") as hsi:\n    waveform = hsi.acquire_waveform(channel=1, points=10000000)\n    # Fast acquisition!\n\nscope.close()'),
      callout('info', 'Architecture', 'This separation is common in networking (control plane vs. data plane) and works great for instrument automation too.'),
    ],
    relatedArticles: ['backend_comparison', 'tekhsi_deep_dive', 'tm_devices_deep_dive'],
  },
  
  // ========== SECTION 3: MEASUREMENTS & COMMANDS ==========
  
  // 3.1 Query vs. Write
  {
    id: 'query_vs_write',
    title: 'The "Query" vs. "Write" Concept',
    category: 'measurements_commands',
    subcategory: 'query_write_concept',
    content: [
      heading(2, 'The Synchronization Problem'),
      paragraph('SCPI commands come in two flavors:'),
      paragraph('• Write: Send a command (no response expected)'),
      paragraph('• Query: Send a command and wait for a response'),
      heading(3, 'The Problem'),
      paragraph('When you send a write command, the instrument starts executing it, but your script continues immediately. If you try to read data before the instrument finishes, you get errors.'),
      code('python', '# WRONG - Race condition\nscope.write(":ACQuire:MODe AVErage")  # Start averaging\nscope.write(":ACQuire:NUMAVg 100")  # Set to 100 averages\ndata = scope.query(":WAVeform:DATA?")  # Try to read immediately\n# Error! Acquisition not finished yet!'),
      heading(3, 'The Solution: *OPC?'),
      paragraph('*OPC? (Operation Complete Query) waits until the previous command finishes before returning.'),
      code('python', '# CORRECT - Wait for completion\nscope.write(":ACQuire:MODe AVErage")\nscope.write(":ACQuire:NUMAVg 100")\nscope.query("*OPC?")  # Wait for averaging to complete\ndata = scope.query(":WAVeform:DATA?")  # Now it\'s ready!'),
      callout('warning', 'When to Use *OPC?', 'Use *OPC? after any command that takes time: acquisitions, file operations, complex measurements. For simple settings (like scale), it\'s usually not needed.'),
    ],
    relatedArticles: ['command_queues', 'setting_vs_querying', 'query_interrupted'],
  },
  
  {
    id: 'command_queues',
    title: 'Command Queues: Why Sending Too Fast Causes Errors',
    category: 'measurements_commands',
    subcategory: 'query_write_concept',
    content: [
      heading(2, 'How Instruments Process Commands'),
      paragraph('Instruments have a command queue. They process commands one at a time. If you send commands faster than the instrument can process them, the queue fills up and commands get dropped or cause errors.'),
      heading(3, 'The Problem'),
      code('python', '# WRONG - Sending commands too fast\nfor i in range(100):\n    scope.write(f":CH1:OFFSet {i * 0.01}")  # 100 commands instantly!\n# Instrument can\'t keep up, commands get lost'),
      heading(3, 'The Solution'),
      paragraph('Add small delays between commands, or use *OPC? to wait for completion:'),
      code('python', '# CORRECT - Rate limiting\nimport time\n\nfor i in range(100):\n    scope.write(f":CH1:OFFSet {i * 0.01}")\n    scope.query("*OPC?")  # Wait for each command\n    # Or add a small delay:\n    # time.sleep(0.01)'),
      callout('tip', 'Rule of Thumb', 'For simple settings, 10-50ms delay is usually enough. For acquisitions or measurements, use *OPC? to wait for actual completion.'),
    ],
    relatedArticles: ['query_vs_write', 'error_tmo'],
  },
  
  {
    id: 'setting_vs_querying',
    title: 'Setting vs. Querying: Why HOR:SCA 40e-6 Sets It, But HOR:SCA? Reads It',
    category: 'measurements_commands',
    subcategory: 'query_write_concept',
    content: [
      heading(2, 'SCPI Command Syntax'),
      paragraph('In SCPI, the same command can both set and query values, depending on whether you include the question mark:'),
      code('python', '# Setting a value (write)\nscope.write(":HORizontal:SCAle 40e-6")  # Set timebase to 40 microseconds\n\n# Querying a value (read)\nscale = scope.query(":HORizontal:SCAle?")  # Read current timebase\nprint(scale)  # Returns "4.00000E-05"'),
      heading(3, 'The Pattern'),
      paragraph('• Command without ? = Write (set a value)'),
      paragraph('• Command with ? = Query (read a value)'),
      paragraph('This applies to almost all SCPI commands.'),
      code('python', '# More examples\nscope.write(":CH1:SCAle 0.5")  # Set channel 1 scale to 0.5V\nscale = scope.query(":CH1:SCAle?")  # Read channel 1 scale\n\nscope.write(":TRIGger:LEVel 1.5")  # Set trigger level\nlevel = scope.query(":TRIGger:LEVel?")  # Read trigger level'),
      callout('tip', 'Trust But Verify', 'After setting a value, query it back to confirm it was applied correctly. This catches errors and confirms the instrument received your command.'),
    ],
    relatedArticles: ['query_vs_write', 'settings_not_applying'],
  },
  
  // 3.2 Waveform Acquisition
  {
    id: 'binary_vs_ascii',
    title: 'Why Use Binary Waveform Transfer?',
    category: 'measurements_commands',
    subcategory: 'waveform_acquisition',
    content: [
      heading(2, 'ASCII vs. Binary (RIBinary)'),
      paragraph('When acquiring waveform data, you have two format options: ASCII (text) and Binary (RIBinary).'),
      heading(3, 'ASCII (The Slow Way)'),
      paragraph('ASCII format sends data as text (like CSV). Each number is a string.'),
      paragraph('Problems:'),
      paragraph('• Slow (10-100x slower than binary)'),
      paragraph('• Truncates precision (limited decimal places)'),
      paragraph('• Large file sizes'),
      paragraph('• CPU intensive (string parsing)'),
      code('python', '# ASCII format\nscope.write(":WAVeform:FORMat ASCii")\ndata = scope.query(":WAVeform:DATA?")\n# Returns: "-1.23,0.45,1.67,..." (text string)'),
      heading(3, 'Binary (RIBinary) - The Right Way'),
      paragraph('RIBinary sends data as raw bytes. Much faster and exact precision.'),
      paragraph('Advantages:'),
      paragraph('• Fast (10-100x faster)'),
      paragraph('• Exact precision (no truncation)'),
      paragraph('• Smaller data size'),
      paragraph('• Less CPU usage'),
      code('python', '# Binary format (RIBinary)\nscope.write(":WAVeform:FORMat RIBinary")\nscope.write(":WAVeform:DATA?")  # Note: query, not write\nraw_data = scope.read_raw()  # Read raw bytes\n# Parse IEEE-488.2 block format\n# Returns: array of floats with full precision'),
      callout('warning', 'Always Use Binary', 'For any serious automation, always use RIBinary format. ASCII is only useful for debugging or one-off manual queries.'),
    ],
    relatedArticles: ['endianness', 'record_length_vs_transfer_time', 'chunk_sizes'],
  },
  
  {
    id: 'endianness',
    title: 'Endianness: Big Endian vs. Little Endian',
    category: 'measurements_commands',
    subcategory: 'waveform_acquisition',
    content: [
      heading(2, 'What is Endianness?'),
      paragraph('Endianness refers to the byte order of multi-byte numbers in memory.'),
      paragraph('• Big Endian: Most significant byte first (network byte order)'),
      paragraph('• Little Endian: Least significant byte first (Intel/AMD CPUs)'),
      heading(3, 'Tektronix Default'),
      paragraph('Tektronix instruments use Big Endian by default for binary data transfers.'),
      paragraph('This means when you read binary waveform data, you must parse it as Big Endian.'),
      code('python', 'import struct\n\n# Reading RIBinary data (Big Endian)\nraw_data = scope.read_raw()\n# Skip IEEE-488.2 block header (#N...)\n# Parse as Big Endian floats\nwaveform = struct.unpack(">f" * num_points, binary_data)  # ">" = Big Endian'),
      callout('info', 'Why Big Endian?', 'Big Endian is the network standard (RFC 1700). Since instruments communicate over networks, using Big Endian ensures compatibility across different systems.'),
    ],
    relatedArticles: ['binary_vs_ascii', 'chunk_sizes'],
  },
  
  {
    id: 'record_length_vs_transfer_time',
    title: 'Record Length vs. Transfer Time: The Math of 10M Points',
    category: 'measurements_commands',
    subcategory: 'waveform_acquisition',
    content: [
      heading(2, 'The Math'),
      paragraph('Transfer time depends on:'),
      paragraph('• Number of points (record length)'),
      paragraph('• Bytes per point (usually 4 bytes for float32)'),
      paragraph('• Transfer speed (MB/s)'),
      heading(3, 'The Formula'),
      paragraph('Time (seconds) = (Points × Bytes per Point) / Transfer Speed'),
      paragraph('Example: 10M points, 4 bytes/point, 5 MB/s:'),
      paragraph('Time = (10,000,000 × 4) / 5,000,000 = 8 seconds'),
      heading(3, 'Real-World Examples'),
      paragraph('1M points (4 MB):'),
      paragraph('• PyVISA: ~1-2 seconds'),
      paragraph('• TekHSI: ~0.1-0.2 seconds'),
      paragraph(''),
      paragraph('10M points (40 MB):'),
      paragraph('• PyVISA: ~8-16 seconds'),
      paragraph('• TekHSI: ~0.8-1.6 seconds'),
      paragraph(''),
      paragraph('100M points (400 MB):'),
      paragraph('• PyVISA: ~80-160 seconds (1.3-2.7 minutes!)'),
      paragraph('• TekHSI: ~8-16 seconds'),
      callout('tip', 'Optimize Record Length', 'Only acquire as many points as you need. 1M points is usually enough for most measurements. 10M+ is only needed for very long timebases or high-resolution analysis.'),
    ],
    relatedArticles: ['binary_vs_ascii', 'chunk_sizes', 'tekhsi_deep_dive'],
  },
  
  {
    id: 'chunk_sizes',
    title: 'Chunk Sizes: Why Reading 100MB in One Go Crashes Python',
    category: 'measurements_commands',
    subcategory: 'waveform_acquisition',
    content: [
      heading(2, 'The Memory Problem'),
      paragraph('Reading a large waveform (100MB+) in a single read operation can:'),
      paragraph('• Exhaust available memory'),
      paragraph('• Cause Python to crash or hang'),
      paragraph('• Trigger timeouts'),
      paragraph('• Overwhelm the network buffer'),
      heading(3, 'The Solution: Chunking'),
      paragraph('Read data in smaller chunks and process incrementally:'),
      code('python', '# WRONG - Reading everything at once\nraw_data = scope.read_raw()  # 100MB? Crash!\n\n# CORRECT - Chunked reading\nchunk_size = 1024 * 1024  # 1MB chunks\nall_data = b""\nwhile True:\n    chunk = scope.read_bytes(chunk_size)\n    if not chunk:\n        break\n    all_data += chunk\n    # Process chunk if needed\n    process_chunk(chunk)'),
      callout('tip', 'Optimal Chunk Size', '1-4 MB chunks are usually optimal. Too small (64KB) adds overhead. Too large (10MB+) risks memory issues.'),
    ],
    relatedArticles: ['record_length_vs_transfer_time', 'binary_vs_ascii'],
  },
  
  {
    id: 'waveform_save_formats',
    title: 'Waveform Save Formats: BIN vs CSV vs WFM vs MAT',
    category: 'measurements_commands',
    subcategory: 'waveform_acquisition',
    content: [
      heading(2, 'Choosing the Right Format'),
      paragraph('When saving waveform data, you have four format options, each with distinct trade-offs. The right choice depends on your workflow: Do you need speed? Analysis-ready data? Full recall on the scope?'),
      
      table(
        ['Format', 'Transport', 'Uses CURVE?', 'Uses SAVE:WAVEFORM', 'Metadata', 'Recallable'],
        [
          ['BIN', 'PC pulls data', '✓', '✗', '✗ None', '✗ No'],
          ['CSV', 'PC pulls data', '✓', '✗', '◐ Partial (scaled)', '✗ No'],
          ['WFM', 'Scope writes file', '✗', '✓', '✓ Full', '✓ Yes'],
          ['MAT', 'Scope writes file', '✗', '✓', '✓ Full', '◐ MATLAB only'],
        ]
      ),
      
      heading(2, 'Format Details'),
      
      heading(3, 'Binary (.bin) — Fastest Raw Transfer'),
      paragraph('Binary format transfers raw ADC samples directly from the scope to your PC using the CURVE? command. This is the fastest method for getting waveform data off the instrument.'),
      paragraph('Pros:'),
      paragraph('• Fastest transfer speed (~10 MB/s with 1 byte/sample)'),
      paragraph('• Smallest file size'),
      paragraph('• Perfect for streaming or real-time acquisition'),
      paragraph('• Works with all scopes'),
      paragraph('Cons:'),
      paragraph('• No metadata (you must query WFMOUTPRE separately for scaling)'),
      paragraph('• Raw ADC counts — requires post-processing to get volts'),
      paragraph('• Cannot be recalled on scope'),
      callout('tip', 'When to Use', 'Use BIN when speed matters most: automated testing, production environments, or capturing many waveforms quickly.'),
      
      heading(3, 'CSV (.csv) — Analysis-Ready'),
      paragraph('CSV format also uses CURVE? but converts the data to scaled, human-readable values with time and amplitude columns.'),
      paragraph('Pros:'),
      paragraph('• Human-readable (Time, Amplitude columns)'),
      paragraph('• Pre-scaled to volts and seconds'),
      paragraph('• Opens in Excel, Python pandas, etc.'),
      paragraph('• Good for sharing with non-programmers'),
      paragraph('Cons:'),
      paragraph('• Slowest transfer (ASCII encoding overhead)'),
      paragraph('• Larger file size than binary'),
      paragraph('• Limited metadata (just scaled values)'),
      paragraph('• Cannot be recalled on scope'),
      callout('tip', 'When to Use', 'Use CSV when you need to analyze data in spreadsheets or share with colleagues who don\'t have specialized tools.'),
      
      heading(3, 'WFM (.wfm) — Tektronix Native'),
      paragraph('WFM is Tektronix\'s proprietary format. The scope writes the file directly using SAVE:WAVEFORM — no CURVE? command is involved.'),
      paragraph('Pros:'),
      paragraph('• Full metadata (all scaling, units, timestamp, probe info)'),
      paragraph('• Recallable on the scope (File → Recall Waveform)'),
      paragraph('• Preserves exact acquisition state'),
      paragraph('• Faster than CSV (scope handles everything)'),
      paragraph('Cons:'),
      paragraph('• Proprietary format (requires Tektronix software to read)'),
      paragraph('• Larger than binary'),
      paragraph('• Requires scope filesystem access'),
      callout('tip', 'When to Use', 'Use WFM when you need to recall waveforms on the scope later, or when preserving complete measurement context is critical.'),
      
      heading(3, 'MAT (.mat) — MATLAB Ready'),
      paragraph('MAT format is MATLAB\'s native data format. Like WFM, the scope writes this directly using SAVE:WAVEFORM.'),
      paragraph('Pros:'),
      paragraph('• Full metadata preserved'),
      paragraph('• Opens directly in MATLAB with load()'),
      paragraph('• Contains structured data (waveform + metadata)'),
      paragraph('• Good for scientific analysis'),
      paragraph('Cons:'),
      paragraph('• Requires MATLAB (or scipy.io.loadmat in Python)'),
      paragraph('• Not human-readable'),
      paragraph('• Limited scope recallability'),
      callout('tip', 'When to Use', 'Use MAT when your analysis workflow is MATLAB-based or when you need structured data with full metadata in Python.'),
      
      heading(2, 'The Critical Rule'),
      callout('warning', 'CURVE? vs SAVE:WAVEFORM', 'BIN and CSV use CURVE? — data is pulled to the PC. WFM and MAT use SAVE:WAVEFORM — the scope writes the file. Never mix these! CURVE? cannot produce WFM files, and SAVE:WAVEFORM cannot produce BIN files.'),
      
      heading(2, 'Decision Flowchart'),
      paragraph('Ask yourself these questions:'),
      paragraph('1. Do I need to recall this waveform on the scope later? → WFM'),
      paragraph('2. Is my analysis workflow in MATLAB? → MAT'),
      paragraph('3. Do I need the fastest possible transfer? → BIN'),
      paragraph('4. Do I need human-readable data for Excel/sharing? → CSV'),
      paragraph('5. Do I need full metadata but will process in Python? → WFM or MAT + scipy'),
      
      heading(2, 'SCPI Commands Reference'),
      heading(3, 'BIN / CSV (PC Transfer)'),
      code('python', '# BIN/CSV: Set up data source and encoding\nscope.write("DATA:SOURCE CH1")\nscope.write("DATA:ENCdg RIBinary")  # or ASCII for CSV\nscope.write("DATA:WIDTH 1")  # 1 or 2 bytes per sample\nscope.write("DATA:START 1")\nscope.write("DATA:STOP 10000")  # or query record length\n\n# Query scaling parameters (for manual scaling)\nx_incr = float(scope.query("WFMOUTPRE:XINCR?"))\ny_mult = float(scope.query("WFMOUTPRE:YMULT?"))\n\n# Transfer data to PC\nraw_data = scope.query_binary_values("CURVE?", ...)'),
      
      heading(3, 'WFM / MAT (Scope Native)'),
      code('python', '# WFM/MAT: Scope writes the file directly\n# NO DATA:*, NO CURVE? — just one command!\nscope.write(\'SAVE:WAVEFORM CH1,"C:/TekScope/data/capture.wfm"\')\nscope.query("*OPC?")  # Wait for save to complete\n\n# Download from scope to PC\nscope.write(\'FILESYSTEM:READFILE "C:/TekScope/data/capture.wfm"\')\ndata = scope.read_raw()\nwith open("capture.wfm", "wb") as f:\n    f.write(data)'),
      
      callout('info', 'Auto-Format in Tek Automator', 'The Save Data step in Tek Automator automatically uses the correct method based on your format selection. BIN/CSV use the optimized read_waveform_binary() function; WFM/MAT use SAVE:WAVEFORM.'),
    ],
    faqs: [
      {
        question: 'Can I convert between formats?',
        answer: 'Yes, but with limitations. You can always go from richer to simpler (WFM → CSV), but you cannot add metadata that wasn\'t captured (BIN → WFM loses metadata). Use the right format from the start.',
      },
      {
        question: 'Which format is best for production testing?',
        answer: 'BIN for speed if you just need pass/fail. WFM if you need to archive captures for later review with full context.',
      },
      {
        question: 'Why is my WFM file not opening in Python?',
        answer: 'WFM is a proprietary Tektronix format. Use the tektronix-wfm library (pip install tektronix-wfm) or convert to MAT and use scipy.io.loadmat().',
      },
      {
        question: 'Can I use CURVE? to create a WFM file?',
        answer: 'No. CURVE? returns raw data that you must save locally. Only SAVE:WAVEFORM can create proper WFM files with full metadata. These are fundamentally different operations.',
      },
    ],
    relatedArticles: ['binary_vs_ascii', 'record_length_vs_transfer_time', 'chunk_sizes', 'hardcopy_vs_filesystem'],
    codeExamples: [
      {
        title: 'Optimized Binary Transfer with read_waveform_binary()',
        language: 'python',
        description: 'The fastest way to transfer waveform data to your PC.',
        code: `def read_waveform_binary(instr, source='CH1', start=1, stop=None, width=1, timeout_ms=30000):
    """Fast binary waveform transfer with auto record-length detection."""
    original_timeout = instr.timeout
    instr.timeout = timeout_ms
    try:
        instr.write(f'DATA:SOURCE {source}')
        instr.write(f'DATA:ENCdg RIBinary')
        instr.write(f'WFMOutpre:BYT_Nr {width}')
        instr.write(f'DATA:START {start}')
        
        if stop is None:
            rec_len = int(instr.query('HORizontal:RECOrdlength?').strip())
            instr.write(f'DATA:STOP {rec_len}')
        else:
            instr.write(f'DATA:STOP {stop}')
        
        # Query preamble for scaling
        preamble = {
            'x_incr': float(instr.query('WFMOutpre:XINcr?').strip()),
            'x_zero': float(instr.query('WFMOutpre:XZEro?').strip()),
            'y_mult': float(instr.query('WFMOutpre:YMUlt?').strip()),
            'y_off': float(instr.query('WFMOutpre:YOFf?').strip()),
            'y_zero': float(instr.query('WFMOutpre:YZEro?').strip()),
            'num_points': int(instr.query('WFMOutpre:NR_Pt?').strip()),
        }
        
        data = instr.query_binary_values('CURVE?', datatype='b' if width == 1 else 'h', 
                                          container=bytes, is_big_endian=True)
        return preamble, data
    finally:
        instr.timeout = original_timeout`,
      },
      {
        title: 'Scope-Native WFM Save',
        language: 'python',
        description: 'Save waveform with full metadata using SAVE:WAVEFORM.',
        code: `# Save CH1 as WFM (scope-native format)
scope_path = 'C:/TekScope/data/capture.wfm'
local_file = 'capture.wfm'

# Scope writes the file directly
scope.write(f'SAVE:WAVEFORM CH1,"{scope_path}"')
scope.query('*OPC?')  # Wait for completion

# Download to PC
scope.write(f'FILESYSTEM:READFILE "{scope_path}"')
wfm_data = scope.read_raw()

# Save locally
with open(local_file, 'wb') as f:
    f.write(wfm_data)

# Clean up scope temp file
scope.write(f'FILESYSTEM:DELETE "{scope_path}"')
print(f"Saved {local_file} with full metadata")`,
      },
    ],
  },
  
  // 3.3 Screenshots & Files
  {
    id: 'inksaver_guide',
    title: 'Pro-Tip: Always Use InkSaver',
    category: 'measurements_commands',
    subcategory: 'screenshots_files',
    content: [
      heading(2, 'The InkSaver Command'),
      paragraph('SAVe:IMAGe:INKSaver ON inverts the screen colors (white background instead of black). This saves printer toner and looks better in Word documents.'),
      code('python', '# Enable InkSaver before saving image\nscope.write("SAVe:IMAGe:INKSaver ON")\nscope.write("SAVe:IMAGe:FILEFormat PNG")\nscope.write("SAVe:IMAGe \'C:\\\\screenshot.png\'")\n\n# Or in one command:\nscope.write("SAVe:IMAGe:INKSaver ON;:SAVe:IMAGe \'C:\\\\screenshot.png\'")'),
      heading(3, 'Why It Matters'),
      paragraph('• Black backgrounds waste printer toner'),
      paragraph('• White backgrounds look professional in reports'),
      paragraph('• Better contrast when printed'),
      paragraph('• Standard practice in technical documentation'),
      callout('tip', 'Always Enable', 'Make InkSaver part of your standard screenshot workflow. It\'s a simple command that makes a big difference in document quality.'),
    ],
    relatedArticles: ['hardcopy_vs_filesystem', 'drive_mapping'],
  },
  
  {
    id: 'drive_mapping',
    title: 'Drive Mapping: Windows vs. Linux Scopes',
    category: 'measurements_commands',
    subcategory: 'screenshots_files',
    content: [
      heading(2, 'File Path Differences'),
      paragraph('Tektronix oscilloscopes run different operating systems, which affects file paths:'),
      heading(3, 'Windows-Based Scopes (MSO 4/5/6/7, DPO7000)'),
      paragraph('Use Windows-style paths:'),
      code('python', '# Windows path\nscope.write("SAVe:IMAGe \'C:\\\\screenshot.png\'")\nscope.write("SAVe:WAVeform \'D:\\\\data.wfm\'")\n\n# Note: Double backslashes in Python strings!'),
      heading(3, 'Linux-Based Scopes (Older models)'),
      paragraph('Use Unix-style paths:'),
      code('python', '# Linux path\nscope.write("SAVe:IMAGe \'/usb0/screenshot.png\'")\nscope.write("SAVe:WAVeform \'/local/data.wfm\'")'),
      callout('warning', 'Check Your Model', 'MSO 4/5/6/7 and DPO7000 use Windows. Older DPO/MSO models may use Linux. Check your instrument\'s documentation or try both path formats.'),
    ],
    relatedArticles: ['inksaver_guide', 'hardcopy_vs_filesystem'],
  },
  
  {
    id: 'hardcopy_vs_filesystem',
    title: 'Hardcopy vs. Filesystem: Two Ways to Get an Image',
    category: 'measurements_commands',
    subcategory: 'screenshots_files',
    content: [
      heading(2, 'Method 1: Hardcopy (Stream Bytes)'),
      paragraph('Hardcopy sends image data directly over the connection as bytes.'),
      paragraph('Advantages:'),
      paragraph('• Fast (no file I/O on scope)'),
      paragraph('• No need to manage files on scope'),
      paragraph('• Works on all instruments'),
      code('python', '# Hardcopy method\nscope.write("HARDCopy:FORMat PNG")\nscope.write("HARDCopy:LAYout PORTrait")\nimage_data = scope.query("HARDCopy:DATA?")  # Returns image bytes\n\n# Save to file on PC\nwith open("screenshot.png", "wb") as f:\n    f.write(image_data)'),
      heading(3, 'Method 2: Filesystem (Save Then Download)'),
      paragraph('Save image to scope\'s disk, then download it.'),
      paragraph('Advantages:'),
      paragraph('• Can save multiple formats'),
      paragraph('• Image stays on scope if needed'),
      paragraph('• Can verify file exists before download'),
      code('python', '# Filesystem method\nscope.write("SAVe:IMAGe:INKSaver ON")\nscope.write("SAVe:IMAGe \'C:\\\\screenshot.png\'")\n\n# Download file (requires file transfer protocol)\n# This varies by backend - see your backend\'s documentation'),
      callout('tip', 'Which to Use?', 'Hardcopy is simpler and faster for one-off screenshots. Filesystem is better if you need to save multiple images or keep them on the scope.'),
    ],
    relatedArticles: ['inksaver_guide', 'drive_mapping'],
  },
  
  // ========== SECTION 4: SCRIPTING & WORKFLOW ==========
  
  // 4.1 From UI to Code
  {
    id: 'generated_script_structure',
    title: 'The Generated Script Structure',
    category: 'scripting_workflow',
    subcategory: 'ui_to_code',
    content: [
      heading(2, 'How TekAutomate Generates Code'),
      paragraph('When you build a workflow in TekAutomate and generate Python code, the output follows a standard structure:'),
      heading(3, '1. Imports'),
      code('python', 'import pyvisa\nimport argparse\n# Or: from tm_devices import DeviceManager'),
      heading(3, '2. Setup (Connection)'),
      code('python', 'def main():\n    p = argparse.ArgumentParser()\n    p.add_argument("--visa", default="TCPIP::192.168.1.50::INSTR")\n    args = p.parse_args()\n    \n    rm = pyvisa.ResourceManager()\n    scope = rm.open_resource(args.visa)\n    scope.timeout = 5000'),
      heading(3, '3. Action Loop (Your Workflow)'),
      code('python', '    # Your steps from the UI\n    scope.write("*RST")\n    scope.write(":CH1:SCAle 0.5")\n    scope.write(":ACQuire:STOPAfter SEQUence")\n    scope.write(":ACQuire:STATE RUN")\n    scope.query("*OPC?")\n    data = scope.query(":WAVeform:DATA?")'),
      heading(3, '4. Teardown (Cleanup)'),
      code('python', '    scope.close()\n    rm.close()\n\nif __name__ == "__main__":\n    main()'),
      callout('info', 'Modular Design', 'Each section is clearly separated, making it easy to modify, add error handling, or wrap in loops.'),
    ],
    relatedArticles: ['running_locally', 'error_handling', 'looping_automation'],
  },
  
  {
    id: 'running_locally',
    title: 'How to Run the Generated Script',
    category: 'scripting_workflow',
    subcategory: 'ui_to_code',
    content: [
      heading(2, 'Quick Start Guide'),
      heading(3, 'Step 1: Install Python'),
      paragraph('Download Python 3.8+ from python.org. Make sure to check "Add Python to PATH" during installation.'),
      heading(3, 'Step 2: Install Dependencies'),
      code('bash', '# Create a virtual environment (recommended)\npython -m venv venv\n\n# Activate it\n# Windows:\nvenv\\Scripts\\activate\n# Linux/Mac:\nsource venv/bin/activate\n\n# Install required packages\npip install pyvisa pyvisa-py\n# Or for tm_devices:\npip install tm-devices'),
      heading(3, 'Step 3: Save Requirements'),
      code('bash', '# Create requirements.txt\npip freeze > requirements.txt'),
      heading(3, 'Step 4: Run the Script'),
      code('bash', '# From command line\npython tek_automation.py --visa "TCPIP::192.168.1.50::INSTR"\n\n# Or in VS Code:\n# 1. Open the script file\n# 2. Press F5 or click "Run"'),
      callout('tip', 'Virtual Environments', 'Always use a virtual environment (venv) to avoid conflicts with other Python projects. It keeps dependencies isolated.'),
    ],
    relatedArticles: ['generated_script_structure', 'error_handling'],
  },
  
  {
    id: 'ai_builder_guide',
    title: 'AI Builder: Generate Blockly Workflows with ChatGPT',
    category: 'scripting_workflow',
    subcategory: 'ui_to_code',
    content: [
      heading(2, 'What is AI Builder?'),
      paragraph('AI Builder is a zero-API integration that connects TekAutomate\'s Blockly editor to a specialized ChatGPT assistant. It helps you generate complete test workflows by describing what you want in plain English.'),
      
      callout('tip', 'No API Keys Required', 'AI Builder uses your own ChatGPT account. TekAutomate never stores, transmits, or processes your prompts through any backend. Everything happens client-side.'),
      
      heading(2, 'How It Works'),
      paragraph('The AI Builder follows a simple 5-step workflow:'),
      paragraph('1. Click "AI Builder" in the Blockly toolbar'),
      paragraph('2. Describe your test workflow in plain English'),
      paragraph('3. Click "Generate" - a context-rich prompt is copied to your clipboard'),
      paragraph('4. TekAutomate GPT XML Builder opens - paste the prompt'),
      paragraph('5. Copy the XML output and click "Paste XML" in Blockly'),
      
      heading(2, 'What Gets Sent to ChatGPT?'),
      paragraph('When you click Generate, TekAutomate builds a prompt containing:'),
      paragraph('• Your current Blockly workspace XML (so AI can modify existing blocks)'),
      paragraph('• Configured instruments (names, models, IP addresses)'),
      paragraph('• Variables already in use'),
      paragraph('• Your workflow description'),
      
      callout('info', 'Context-Aware Generation', 'Because the AI sees your current workspace, it can add to existing blocks, fix errors, or modify specific sections rather than starting from scratch.'),
      
      heading(2, 'Privacy & Security'),
      
      table(
        ['Concern', 'How AI Builder Addresses It'],
        [
          ['API Keys', 'None required - uses your ChatGPT account'],
          ['Data Storage', 'Nothing stored - prompt copied to clipboard only'],
          ['Backend Processing', 'None - everything is client-side JavaScript'],
          ['Network Requests', 'Only opens chatgpt.com in new tab'],
          ['Instrument IPs', 'Only included if you have devices configured'],
          ['Code Privacy', 'Your code never leaves your browser until you paste'],
        ]
      ),
      
      heading(3, 'Enterprise & Air-Gapped Environments'),
      paragraph('Since AI Builder only copies text to clipboard and opens a URL, it works in restricted environments:'),
      paragraph('• No outbound API calls from TekAutomate'),
      paragraph('• Works with ChatGPT Enterprise (your org\'s data policies apply)'),
      paragraph('• Can be disabled by simply not clicking the button'),
      paragraph('• No telemetry, no analytics, no tracking'),
      
      heading(2, 'Example Prompts'),
      
      heading(3, 'Basic Scope Setup'),
      code('text', 'Connect to scope at 192.168.1.100, enable CH1, set 1V scale, \ncapture single acquisition, save waveform as capture.wfm, disconnect'),
      
      heading(3, 'Voltage Sweep'),
      code('text', 'Connect to SMU at 192.168.1.15 and scope at 192.168.1.10.\nSweep SMU voltage from 0 to 5V in 0.5V steps.\nAt each step, measure CH1 amplitude and log to CSV.'),
      
      heading(3, 'Fixing Errors'),
      code('text', 'Fix the import error - the HOST field is missing from connect_scope block'),
      
      heading(3, 'Adding Features'),
      code('text', 'Add FastFrame capture with 100 frames to the existing workflow'),
      
      heading(2, 'Tips for Better Results'),
      paragraph('• Be specific about IP addresses and instrument types'),
      paragraph('• Mention the format you want (CSV, WFM, BIN)'),
      paragraph('• If modifying existing blocks, describe what to change'),
      paragraph('• For complex workflows, break into smaller requests'),
      paragraph('• Always review the generated XML before running'),
      
      callout('warning', 'Always Verify', 'AI-generated code should be reviewed before execution. Check that IP addresses, SCPI commands, and file paths match your actual setup.'),
      
      heading(2, 'Why Not a Built-in API?'),
      paragraph('We chose the clipboard + ChatGPT approach for several reasons:'),
      paragraph('• Zero cost - no API fees for users'),
      paragraph('• Zero maintenance - no API keys to manage or rotate'),
      paragraph('• Full privacy - your prompts never touch our servers'),
      paragraph('• Flexibility - works with ChatGPT Plus, Team, or Enterprise'),
      paragraph('• Transparency - you see exactly what gets sent'),
      paragraph('• Control - you decide when and what to share'),
    ],
    faqs: [
      {
        question: 'Do I need a ChatGPT Plus subscription?',
        answer: 'The Custom GPT works best with ChatGPT Plus or Team, but free tier users can also try it with limitations.',
      },
      {
        question: 'Can I use this offline?',
        answer: 'No, you need internet access to reach chatgpt.com. However, TekAutomate itself works fully offline - only the AI Builder feature requires internet.',
      },
      {
        question: 'Is my instrument IP address shared?',
        answer: 'Only if you have devices configured in TekAutomate. The IP is included in the prompt so the AI can generate correct connection blocks. This goes to ChatGPT, not to us.',
      },
      {
        question: 'Can I use a different AI model?',
        answer: 'The prompt is just text in your clipboard. You can paste it into any AI assistant (Claude, Gemini, local LLM) - though results may vary without the Custom GPT\'s specialized training.',
      },
      {
        question: 'What if the generated XML has errors?',
        answer: 'Paste it anyway - Blockly will show validation errors. You can then ask the AI to fix specific issues, or manually adjust blocks in the editor.',
      },
    ],
    relatedArticles: ['generated_script_structure', 'running_locally'],
  },
  
  // 4.2 Advanced Patterns
  {
    id: 'error_handling',
    title: 'Error Handling: Catching VISA Timeouts',
    category: 'scripting_workflow',
    subcategory: 'advanced_patterns',
    content: [
      heading(2, 'Why Error Handling Matters'),
      paragraph('VISA operations can fail for many reasons: connection lost, timeout, instrument error, etc. Without error handling, your script crashes.'),
      heading(3, 'Basic Error Handling'),
      code('python', 'import pyvisa\nfrom pyvisa import VisaIOError\n\ntry:\n    rm = pyvisa.ResourceManager()\n    scope = rm.open_resource("TCPIP::192.168.1.50::INSTR")\n    scope.write("*IDN?")\n    idn = scope.read()\n    print(f"Connected: {idn}")\nexcept VisaIOError as e:\n    print(f"VISA Error: {e}")\nexcept Exception as e:\n    print(f"Unexpected error: {e}")\nfinally:\n    if "scope" in locals():\n        scope.close()'),
      heading(3, 'Common VISA Errors'),
      paragraph('• VisaIOError: General I/O error (timeout, connection lost)'),
      paragraph('• VI_ERROR_TMO: Timeout (command took too long)'),
      paragraph('• VI_ERROR_RSRC_NFOUND: Resource not found (wrong IP, not connected)'),
      paragraph('• VI_ERROR_CONN_LOST: Connection lost (cable unplugged, scope powered off)'),
      callout('warning', 'Always Use Try/Except', 'Never assume a VISA operation will succeed. Always wrap connection and command operations in try/except blocks.'),
    ],
    relatedArticles: ['error_tmo', 'error_rsrc_nfound', 'connection_refused'],
  },
  
  {
    id: 'looping_automation',
    title: 'Looping/Automation: Capturing 100 Times',
    category: 'scripting_workflow',
    subcategory: 'advanced_patterns',
    content: [
      heading(2, 'Wrapping Generated Code in a Loop'),
      paragraph('To capture data multiple times, wrap the generated workflow in a loop:'),
      code('python', 'import pyvisa\nimport time\n\nrm = pyvisa.ResourceManager()\nscope = rm.open_resource("TCPIP::192.168.1.50::INSTR")\n\n# Capture 100 times\nfor i in range(100):\n    print(f"Capture {i+1}/100")\n    \n    # Your generated workflow here\n    scope.write("*RST")\n    scope.write(":ACQuire:STATE RUN")\n    scope.query("*OPC?")\n    \n    # Save data with unique filename\n    data = scope.query(":WAVeform:DATA?")\n    with open(f"capture_{i:03d}.csv", "w") as f:\n        f.write(data)\n    \n    # Optional: delay between captures\n    time.sleep(0.1)\n\nscope.close()'),
      callout('tip', 'Unique Filenames', 'Use formatted numbers (i:03d) to create sequential filenames: capture_000.csv, capture_001.csv, etc.'),
    ],
    relatedArticles: ['data_logging', 'generated_script_structure'],
  },
  
  {
    id: 'data_logging',
    title: 'Data Logging: Saving Results to CSV',
    category: 'scripting_workflow',
    subcategory: 'advanced_patterns',
    content: [
      heading(2, 'Modifying Scripts for Data Logging'),
      paragraph('Add CSV logging to track measurements over time:'),
      code('python', 'import csv\nimport datetime\n\n# Open CSV file for writing\nwith open("measurements.csv", "w", newline="") as f:\n    writer = csv.writer(f)\n    writer.writerow(["Timestamp", "Voltage", "Frequency", "Amplitude"])\n    \n    # Your measurement loop\n    for i in range(100):\n        # Take measurement\n        voltage = float(scope.query(":MEASure:VOLTage:AMPLitude? CH1"))\n        freq = float(scope.query(":MEASure:FREQuency? CH1"))\n        \n        # Log to CSV\n        timestamp = datetime.datetime.now().isoformat()\n        writer.writerow([timestamp, voltage, freq, amplitude])\n        \n        time.sleep(1)  # Wait 1 second between measurements'),
      callout('tip', 'CSV Format', 'CSV files are easy to open in Excel, Python pandas, or any data analysis tool. Include timestamps for time-series analysis.'),
    ],
    relatedArticles: ['looping_automation', 'generated_script_structure'],
  },
  
  // ========== SECTION 5: TROUBLESHOOTING ==========
  
  // 5.1 Connection Errors
  {
    id: 'error_rsrc_nfound',
    title: 'VI_ERROR_RSRC_NFOUND: Resource Not Found',
    category: 'troubleshooting',
    subcategory: 'connection_errors',
    content: [
      heading(2, 'What This Error Means'),
      paragraph('The instrument couldn\'t be found at the specified address.'),
      heading(3, 'Troubleshooting Checklist'),
      paragraph('1. Check IP Address:'),
      paragraph('   • Is the IP correct? Verify on the scope\'s front panel'),
      paragraph('   • Use LXI web interface to confirm scope is alive'),
      paragraph(''),
      paragraph('2. Check Cable:'),
      paragraph('   • Is the Ethernet cable connected?'),
      paragraph('   • Try a different cable'),
      paragraph('   • Check for physical damage'),
      paragraph(''),
      paragraph('3. Check Network:'),
      paragraph('   • Are PC and scope on the same network?'),
      paragraph('   • Can you ping the scope? (ping 192.168.1.50)'),
      paragraph('   • Is a firewall blocking the connection?'),
      paragraph(''),
      paragraph('4. Check Typo:'),
      paragraph('   • Verify resource string is correct'),
      paragraph('   • Check for extra spaces or wrong characters'),
      code('python', '# Common mistakes:\n"TCPIP::192.168.1.50::INSTR"  # Correct\n"TCPIP::192.168.1.50::INSTR "  # Extra space - WRONG\n"TCPIP::192.168.1.50::INST"   # Typo - WRONG'),
    ],
    relatedArticles: ['finding_ip_address', 'lxi_web_interface', 'visa_resource_explained'],
  },
  
  {
    id: 'error_tmo',
    title: 'VI_ERROR_TMO: Timeout Error',
    category: 'troubleshooting',
    subcategory: 'connection_errors',
    content: [
      heading(2, 'What This Error Means'),
      paragraph('The instrument didn\'t respond within the timeout period.'),
      heading(3, 'Common Causes'),
      paragraph('1. Missing Termination Character (\\n):'),
      paragraph('   • With raw sockets, you must add \\n to every command'),
      paragraph('   • Check: Did you forget the newline?'),
      paragraph(''),
      paragraph('2. Trigger Not Stopped:'),
      paragraph('   • If scope is waiting for a trigger, queries may timeout'),
      paragraph('   • Solution: Stop acquisition or wait for trigger'),
      paragraph(''),
      paragraph('3. Acquisition Too Long:'),
      paragraph('   • Very long acquisitions (100M points) take minutes'),
      paragraph('   • Solution: Increase timeout or reduce record length'),
      paragraph(''),
      paragraph('4. Instrument Busy:'),
      paragraph('   • Instrument is processing a previous command'),
      paragraph('   • Solution: Use *OPC? to wait for completion'),
      code('python', '# Increase timeout for long operations\nscope.timeout = 30000  # 30 seconds\n\n# Or wait for completion\nscope.write(":ACQuire:STATE RUN")\nscope.query("*OPC?")  # Wait for acquisition\n# Now safe to query data'),
    ],
    relatedArticles: ['termination_characters', 'query_vs_write', 'command_queues'],
  },
  
  {
    id: 'connection_refused',
    title: 'Connection Refused: Troubleshooting',
    category: 'troubleshooting',
    subcategory: 'connection_errors',
    content: [
      heading(2, 'What This Error Means'),
      paragraph('The instrument is reachable but refusing the connection.'),
      heading(3, 'Possible Causes'),
      paragraph('1. Another PC Connected:'),
      paragraph('   • SCPI connections are often exclusive'),
      paragraph('   • Check if another computer is controlling the scope'),
      paragraph('   • Disconnect other sessions first'),
      paragraph(''),
      paragraph('2. Scope\'s Server Feature Turned Off:'),
      paragraph('   • Check Utility → I/O → Network'),
      paragraph('   • Ensure "SCPI Server" or "Remote Control" is enabled'),
      paragraph('   • Some scopes require a reboot after enabling'),
      paragraph(''),
      paragraph('3. Wrong Port:'),
      paragraph('   • Port 4000 vs. 5025 vs. 1024'),
      paragraph('   • Try different ports or use VXI-11 (INSTR)'),
      paragraph(''),
      paragraph('4. Firewall on Scope:'),
      paragraph('   • Windows-based scopes may have Windows Firewall enabled'),
      paragraph('   • Check firewall settings on the scope'),
      callout('warning', 'Exclusive Connections', 'Many instruments only allow one SCPI connection at a time. Close other connections (other scripts, Tektronix software) before connecting.'),
    ],
    relatedArticles: ['port_numbers', 'mso_456_permissions', 'error_rsrc_nfound'],
  },
  
  // 5.2 Data Errors
  {
    id: 'query_interrupted',
    title: 'Query Interrupted: Reading Before Completion',
    category: 'troubleshooting',
    subcategory: 'data_errors',
    content: [
      heading(2, 'The Problem'),
      paragraph('You tried to read data before the instrument finished the previous operation.'),
      code('python', '# WRONG - Race condition\nscope.write(":ACQuire:STATE RUN")\ndata = scope.query(":WAVeform:DATA?")  # Too soon!'),
      heading(3, 'The Solution'),
      paragraph('Wait for completion using *OPC?:'),
      code('python', '# CORRECT - Wait for completion\nscope.write(":ACQuire:STATE RUN")\nscope.query("*OPC?")  # Wait for acquisition\ndata = scope.query(":WAVeform:DATA?")  # Now it\'s ready'),
      callout('tip', 'When to Wait', 'Always use *OPC? after: acquisitions, file operations, complex measurements, or any operation that takes time.'),
    ],
    relatedArticles: ['query_vs_write', 'command_queues'],
  },
  
  {
    id: 'truncated_data',
    title: 'Truncated Data: Byte Count Mismatch',
    category: 'troubleshooting',
    subcategory: 'data_errors',
    content: [
      heading(2, 'The Problem'),
      paragraph('The data you received doesn\'t match the expected size. This usually means the read was incomplete.'),
      heading(3, 'Common Causes'),
      paragraph('1. Timeout Too Short:'),
      paragraph('   • Large datasets need longer timeouts'),
      paragraph('   • Solution: Increase timeout for large reads'),
      paragraph(''),
      paragraph('2. Incomplete Read:'),
      paragraph('   • read() may not get all data in one call'),
      paragraph('   • Solution: Use read_raw() or chunked reading'),
      paragraph(''),
      paragraph('3. Wrong Byte Count in Header:'),
      paragraph('   • IEEE-488.2 block format has a header (#N...)'),
      paragraph('   • If header is wrong, byte count is wrong'),
      code('python', '# Read all data (handles chunking)\ndef read_all_data(scope, expected_size):\n    data = b""\n    while len(data) < expected_size:\n        chunk = scope.read_bytes(min(1024, expected_size - len(data)))\n        if not chunk:\n            break\n        data += chunk\n    return data'),
    ],
    relatedArticles: ['chunk_sizes', 'binary_vs_ascii', 'error_tmo'],
  },
  
  {
    id: 'settings_not_applying',
    title: 'Settings Not Applying: Trust But Verify',
    category: 'troubleshooting',
    subcategory: 'data_errors',
    content: [
      heading(2, 'The Problem'),
      paragraph('You send a command to set a value, but when you query it back, it\'s different (or unchanged).'),
      heading(3, 'Why This Happens'),
      paragraph('• Command syntax error (instrument ignored it)'),
      paragraph('• Value out of range (instrument clamped it)'),
      paragraph('• Instrument in wrong mode (setting not applicable)'),
      paragraph('• Command not supported on this model'),
      heading(3, 'The Solution: Trust But Verify'),
      code('python', '# Always verify settings\nscope.write(":CH1:SCAle 0.5")\nactual_scale = float(scope.query(":CH1:SCAle?"))\n\nif abs(actual_scale - 0.5) > 0.001:  # Allow small floating-point error\n    print(f"Warning: Scale not set correctly. Expected 0.5, got {actual_scale}")\nelse:\n    print("Scale set correctly")'),
      callout('warning', 'Always Verify', 'Never assume a write command succeeded. Always query the value back and verify it matches what you intended.'),
    ],
    relatedArticles: ['setting_vs_querying', 'query_vs_write'],
  },
  
  // 5.3 Driver Issues
  {
    id: 'nivisa_vs_pyvisa_py',
    title: 'NI-VISA vs. PyVISA-py: Which Backend to Use?',
    category: 'troubleshooting',
    subcategory: 'driver_issues',
    content: [
      heading(2, 'Two VISA Backends'),
      paragraph('PyVISA can use two different backends:'),
      heading(3, 'NI-VISA (Native Backend)'),
      paragraph('• Requires National Instruments VISA drivers'),
      paragraph('• More features and better performance'),
      paragraph('• Requires installation of NI-VISA Runtime'),
      paragraph('• Windows/Linux only (no macOS)'),
      paragraph('• Better for production environments'),
      code('python', '# Using NI-VISA backend\nimport pyvisa\nrm = pyvisa.ResourceManager("@ni")  # "@ni" = NI-VISA'),
      heading(3, 'PyVISA-py (Pure Python)'),
      paragraph('• Pure Python implementation, no drivers needed'),
      paragraph('• Works on Windows, Linux, and macOS'),
      paragraph('• Easier installation (just pip install)'),
      paragraph('• Some limitations (fewer features)'),
      paragraph('• Better for development and cross-platform'),
      code('python', '# Using PyVISA-py backend\nimport pyvisa\nrm = pyvisa.ResourceManager("@py")  # "@py" = PyVISA-py'),
      heading(3, 'When to Switch'),
      paragraph('Switch to PyVISA-py if:'),
      paragraph('• You\'re on macOS (NI-VISA doesn\'t support it)'),
      paragraph('• You don\'t want to install NI drivers'),
      paragraph('• You\'re having driver conflicts'),
      paragraph(''),
      paragraph('Stick with NI-VISA if:'),
      paragraph('• You need maximum performance'),
      paragraph('• You\'re using GPIB (better support)'),
      paragraph('• You\'re in a production environment'),
    ],
    relatedArticles: ['pyvisa_deep_dive', 'driver_conflicts'],
  },
  
  {
    id: 'driver_conflicts',
    title: 'Driver Conflicts: Multiple VISA Libraries',
    category: 'troubleshooting',
    subcategory: 'driver_issues',
    content: [
      heading(2, 'The Problem'),
      paragraph('Having multiple VISA libraries installed (Keysight IO Libraries, TekVISA, NI-VISA) can cause conflicts.'),
      heading(3, 'Symptoms'),
      paragraph('• Instruments not found even though they\'re connected'),
      paragraph('• Resource strings work in one tool but not another'),
      paragraph('• Strange errors about resource managers'),
      paragraph('• One VISA library "takes over" and others can\'t see instruments'),
      heading(3, 'Solutions'),
      paragraph('1. Use PyVISA-py (No Drivers):'),
      paragraph('   • Pure Python, avoids driver conflicts'),
      paragraph('   • Use ResourceManager("@py")'),
      paragraph(''),
      paragraph('2. Specify Backend Explicitly:'),
      code('python', '# Force specific backend\nrm = pyvisa.ResourceManager("@ni")  # Force NI-VISA\n# Or\nrm = pyvisa.ResourceManager("@py")  # Force PyVISA-py'),
      paragraph(''),
      paragraph('3. Uninstall Conflicting Drivers:'),
      paragraph('   • Keep only one VISA library if possible'),
      paragraph('   • NI-VISA is usually the most compatible'),
      callout('warning', 'Driver Hell', 'VISA driver conflicts are a common source of frustration. When in doubt, use PyVISA-py to avoid the problem entirely.'),
    ],
    relatedArticles: ['nivisa_vs_pyvisa_py', 'error_rsrc_nfound'],
  },
  
  // ========== ADDITIONAL TOPICS ==========
  
  // Performance & Optimization
  {
    id: 'multi_device_workflows',
    title: 'Managing Multiple Tektronix Instruments Simultaneously',
    category: 'scripting_workflow',
    subcategory: 'advanced_patterns',
    content: [
      heading(2, 'Coordinating Multiple Instruments'),
      paragraph('Many test setups require controlling multiple Tektronix instruments at once: multiple oscilloscopes, AWGs, SMUs, or a combination. Here\'s how to manage them effectively.'),
      heading(3, 'Using DeviceManager (tm_devices)'),
      paragraph('DeviceManager makes multi-device coordination easy:'),
      code('python', 'from tm_devices import DeviceManager\nfrom tm_devices.drivers import MSO6, AWG5200\n\nwith DeviceManager() as dm:\n    # Add multiple instruments\n    scope1 = dm.add_scope("192.168.1.50", alias="scope1")\n    scope2 = dm.add_scope("192.168.1.51", alias="scope2")\n    awg = dm.add_awg("192.168.1.52", alias="awg1")\n    \n    # Control them independently\n    scope1.ch[1].scale = 0.5\n    scope2.ch[1].scale = 1.0\n    awg.ch[1].amplitude = 2.0\n    \n    # Synchronize operations\n    scope1.write(":ACQuire:STATE RUN")\n    scope2.write(":ACQuire:STATE RUN")\n    scope1.query("*OPC?")\n    scope2.query("*OPC?")\n    \n    # All connections closed automatically on exit'),
      heading(3, 'Using PyVISA for Multiple Devices'),
      code('python', 'import pyvisa\n\nrm = pyvisa.ResourceManager()\n\n# Open multiple connections\nscope1 = rm.open_resource("TCPIP::192.168.1.50::INSTR")\nscope2 = rm.open_resource("TCPIP::192.168.1.51::INSTR")\nawg = rm.open_resource("TCPIP::192.168.1.52::INSTR")\n\n# Set unique timeouts\nscope1.timeout = 5000\nscope2.timeout = 5000\nawg.timeout = 10000\n\n# Control devices\nscope1.write("*RST")\nscope2.write("*RST")\nawg.write("*RST")\n\n# Synchronize\nscope1.write(":ACQuire:STATE RUN")\nscope2.write(":ACQuire:STATE RUN")\nscope1.query("*OPC?")\nscope2.query("*OPC?")\n\n# Cleanup\nscope1.close()\nscope2.close()\nawg.close()\nrm.close()'),
      heading(3, 'Best Practices'),
      paragraph('• Use unique aliases or variables for each instrument'),
      paragraph('• Set appropriate timeouts for each device'),
      paragraph('• Synchronize operations using *OPC? when needed'),
      paragraph('• Use DeviceManager for automatic cleanup'),
      paragraph('• Consider using threading for parallel operations (advanced)'),
      callout('tip', 'Synchronization', 'When triggering multiple scopes simultaneously, use *OPC? on each device to ensure they\'re all ready before proceeding.'),
    ],
    relatedArticles: ['tm_devices_deep_dive', 'error_handling', 'automation_best_practices'],
  },
  
  {
    id: 'performance_optimization',
    title: 'Performance Optimization: Best Practices for Fast Data Acquisition',
    category: 'scripting_workflow',
    subcategory: 'advanced_patterns',
    content: [
      heading(2, 'Optimizing Your Automation Scripts'),
      paragraph('When automating Tektronix instruments, performance matters. Here are proven techniques to speed up your workflows.'),
      heading(3, '1. Minimize Record Length'),
      paragraph('Only acquire as many points as you need:'),
      code('python', '# SLOW - Acquiring more than needed\nscope.write(":HORizontal:RECOrdlength 10000000")  # 10M points\nscope.write(":ACQuire:STATE RUN")\n\n# FAST - Only what you need\nscope.write(":HORizontal:RECOrdlength 1000000")  # 1M points\nscope.write(":ACQuire:STATE RUN")\n# 10x faster transfer!'),
      heading(3, '2. Use Binary Format (RIBinary)'),
      paragraph('Always use binary for waveform data:'),
      code('python', '# SLOW - ASCII\nscope.write(":WAVeform:FORMat ASCii")\ndata = scope.query(":WAVeform:DATA?")\n\n# FAST - Binary\nscope.write(":WAVeform:FORMat RIBinary")\ndata = scope.query(":WAVeform:DATA?")\n# 10-100x faster!'),
      heading(3, '3. Use TekHSI for Large Datasets'),
      paragraph('For MSO 4/5/6/7 Series with SFP+ port:'),
      code('python', '# SLOW - PyVISA for 10M points (~8-16 seconds)\nscope.write(":WAVeform:DATA?")\ndata = scope.read_raw()\n\n# FAST - TekHSI (~0.8-1.6 seconds)\nfrom tekhsi import TekHSIConnect\nwith TekHSIConnect("192.168.1.50") as hsi:\n    data = hsi.acquire_waveform(channel=1, points=10000000)\n# 10x faster!'),
      heading(3, '4. Batch Commands When Possible'),
      paragraph('Send multiple commands in one write:'),
      code('python', '# SLOW - Multiple writes\nscope.write(":CH1:SCAle 0.5")\nscope.write(":CH1:OFFSet 0")\nscope.write(":CH1:COUPling DC")\n\n# FAST - Batched\nscope.write(":CH1:SCAle 0.5;:CH1:OFFSet 0;:CH1:COUPling DC")'),
      heading(3, '5. Avoid Unnecessary Queries'),
      paragraph('Don\'t query values you don\'t need:'),
      code('python', '# SLOW - Querying everything\nscale = scope.query(":CH1:SCAle?")\noffset = scope.query(":CH1:OFFSet?")\ncoupling = scope.query(":CH1:COUPling?")\n\n# FAST - Only query what you need\n# (Don\'t query at all if you just set the values)'),
      heading(3, '6. Use Appropriate Timeouts'),
      paragraph('Set timeouts based on operation length:'),
      code('python', '# For quick operations\nscope.timeout = 2000  # 2 seconds\n\n# For long acquisitions\nscope.timeout = 30000  # 30 seconds\n\n# For very long operations (100M points)\nscope.timeout = 120000  # 2 minutes'),
      callout('tip', 'Profile Your Script', 'Use Python\'s time.time() to measure how long operations take. Identify bottlenecks and optimize those first.'),
    ],
    relatedArticles: ['binary_vs_ascii', 'tekhsi_deep_dive', 'record_length_vs_transfer_time', 'chunk_sizes'],
  },
  
  {
    id: 'memory_management',
    title: 'Memory Management: Handling Large Datasets Without Crashing',
    category: 'measurements_commands',
    subcategory: 'waveform_acquisition',
    content: [
      heading(2, 'The Memory Challenge'),
      paragraph('Tektronix oscilloscopes can acquire massive datasets (100M+ points). Processing these in Python requires careful memory management.'),
      heading(3, '1. Chunked Reading'),
      paragraph('Read data in manageable chunks:'),
      code('python', '# WRONG - Reading everything at once\nraw_data = scope.read_raw()  # 400MB? Crash!\n\n# CORRECT - Chunked reading\nchunk_size = 2 * 1024 * 1024  # 2MB chunks\nall_data = b""\nwhile True:\n    chunk = scope.read_bytes(chunk_size)\n    if not chunk:\n        break\n    all_data += chunk\n    # Process incrementally if possible'),
      heading(3, '2. Process Incrementally'),
      paragraph('Process data as you read it, don\'t store everything:'),
      code('python', '# Process while reading (memory efficient)\ndef process_waveform_stream(scope, num_points):\n    chunk_size = 1024 * 1024  # 1MB\n    points_processed = 0\n    \n    while points_processed < num_points:\n        chunk = scope.read_bytes(chunk_size)\n        if not chunk:\n            break\n        \n        # Process chunk immediately\n        waveform_chunk = parse_binary_data(chunk)\n        analyze_chunk(waveform_chunk)  # Don\'t store, just analyze\n        \n        points_processed += len(waveform_chunk)\n        \n        # Optional: Save to disk instead of memory\n        save_chunk_to_disk(waveform_chunk, points_processed)'),
      heading(3, '3. Use Generators for Large Datasets'),
      code('python', 'def read_waveform_generator(scope, chunk_size=1024*1024):\n    """Generator that yields chunks instead of loading all at once"""\n    while True:\n        chunk = scope.read_bytes(chunk_size)\n        if not chunk:\n            break\n        yield parse_binary_data(chunk)\n\n# Use generator (memory efficient)\nfor chunk in read_waveform_generator(scope):\n    process(chunk)  # Process one chunk at a time'),
      heading(3, '4. Save to Disk, Not Memory'),
      paragraph('For very large datasets, write directly to disk:'),
      code('python', 'import numpy as np\n\n# Write directly to file (no memory buffer)\nwith open("waveform.bin", "wb") as f:\n    chunk_size = 2 * 1024 * 1024  # 2MB\n    while True:\n        chunk = scope.read_bytes(chunk_size)\n        if not chunk:\n            break\n        f.write(chunk)  # Write immediately\n\n# Later, read from disk in chunks\nwith open("waveform.bin", "rb") as f:\n    # Process file in chunks'),
      heading(3, '5. Use NumPy Memory-Mapped Files'),
      code('python', 'import numpy as np\n\n# Create memory-mapped array (doesn\'t load all into RAM)\nnum_points = 100000000  # 100M points\nwaveform = np.memmap("waveform.dat", dtype=np.float32, mode="w+", shape=(num_points,))\n\n# Write data in chunks\nchunk_size = 1000000  # 1M points at a time\nfor i in range(0, num_points, chunk_size):\n    chunk = scope.read_bytes(chunk_size * 4)  # 4 bytes per float\n    waveform[i:i+chunk_size] = np.frombuffer(chunk, dtype=">f4")  # Big endian float32'),
      callout('warning', 'Memory Limits', 'Python on 32-bit systems is limited to ~2GB RAM. On 64-bit, you have more headroom, but still be careful with 100M+ point datasets.'),
    ],
    relatedArticles: ['chunk_sizes', 'record_length_vs_transfer_time', 'binary_vs_ascii'],
  },
  
  {
    id: 'automation_best_practices',
    title: 'Automation Best Practices: Code Organization, Error Recovery, and Logging',
    category: 'scripting_workflow',
    subcategory: 'advanced_patterns',
    content: [
      heading(2, 'Writing Production-Grade Automation Scripts'),
      paragraph('Follow these best practices when automating Tektronix instruments for reliable, maintainable code.'),
      heading(3, '1. Code Organization'),
      paragraph('Structure your code into logical functions:'),
      code('python', 'import pyvisa\nimport logging\nfrom typing import Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\'%(asctime)s - %(levelname)s - %(message)s\',\n    handlers=[\n        logging.FileHandler(\'automation.log\'),\n        logging.StreamHandler()\n    ]\n)\n\ndef connect_to_scope(ip: str, timeout: int = 5000) -> Optional[pyvisa.Resource]:\n    """Connect to oscilloscope with error handling"""\n    try:\n        rm = pyvisa.ResourceManager()\n        scope = rm.open_resource(f"TCPIP::{ip}::INSTR")\n        scope.timeout = timeout\n        logging.info(f"Connected to scope at {ip}")\n        return scope\n    except Exception as e:\n        logging.error(f"Failed to connect: {e}")\n        return None\n\ndef configure_scope(scope: pyvisa.Resource, channel: int, scale: float):\n    """Configure scope channel"""\n    try:\n        scope.write(f":CH{channel}:SCAle {scale}")\n        actual = float(scope.query(f":CH{channel}:SCAle?"))\n        if abs(actual - scale) > 0.001:\n            logging.warning(f"Scale mismatch: expected {scale}, got {actual}")\n        logging.info(f"Channel {channel} configured: {scale}V/div")\n    except Exception as e:\n        logging.error(f"Failed to configure channel {channel}: {e}")\n        raise\n\ndef acquire_waveform(scope: pyvisa.Resource, channel: int) -> Optional[bytes]:\n    """Acquire waveform from specified channel"""\n    try:\n        scope.write(f":DATa:SOUrce CH{channel}")\n        scope.write(":WAVeform:FORMat RIBinary")\n        scope.write(":ACQuire:STATE RUN")\n        scope.query("*OPC?")\n        \n        scope.write(":WAVeform:DATA?")\n        data = scope.read_raw()\n        logging.info(f"Acquired waveform from CH{channel}: {len(data)} bytes")\n        return data\n    except Exception as e:\n        logging.error(f"Failed to acquire waveform: {e}")\n        return None\n\ndef main():\n    scope = connect_to_scope("192.168.1.50")\n    if not scope:\n        return\n    \n    try:\n        configure_scope(scope, 1, 0.5)\n        data = acquire_waveform(scope, 1)\n        if data:\n            # Process data\n            pass\n    finally:\n        scope.close()\n        logging.info("Connection closed")'),
      heading(3, '2. Error Recovery'),
      paragraph('Implement retry logic for transient errors:'),
      code('python', 'from time import sleep\n\ndef robust_query(scope, command, max_retries=3, delay=0.1):\n    """Query with automatic retry on failure"""\n    for attempt in range(max_retries):\n        try:\n            return scope.query(command)\n        except pyvisa.VisaIOError as e:\n            if attempt < max_retries - 1:\n                logging.warning(f"Query failed (attempt {attempt+1}/{max_retries}): {e}")\n                sleep(delay)\n                continue\n            else:\n                logging.error(f"Query failed after {max_retries} attempts: {e}")\n                raise'),
      heading(3, '3. Logging Strategy'),
      paragraph('Log important events and errors:'),
      code('python', 'import logging\n\n# Different log levels\nlogging.debug("Detailed debugging info")  # Development only\nlogging.info("Normal operation info")  # What\'s happening\nlogging.warning("Something unexpected but handled")  # Recoverable issues\nlogging.error("Error occurred but script continues")  # Errors\nlogging.critical("Critical error, script may fail")  # Fatal errors'),
      heading(3, '4. Configuration Management'),
      paragraph('Separate configuration from code:'),
      code('python', 'import json\nfrom dataclasses import dataclass\n\n@dataclass\nclass ScopeConfig:\n    ip: str\n    timeout: int = 5000\n    channel: int = 1\n    scale: float = 0.5\n    record_length: int = 1000000\n\n# Load from JSON file\nwith open("config.json") as f:\n    config_data = json.load(f)\n    config = ScopeConfig(**config_data)\n\n# Use in code\nscope = connect_to_scope(config.ip, config.timeout)'),
      heading(3, '5. Resource Cleanup'),
      paragraph('Always clean up resources, even on errors:'),
      code('python', '# Use context managers\nfrom tm_devices import DeviceManager\n\nwith DeviceManager() as dm:\n    scope = dm.add_scope("192.168.1.50")\n    # Automatic cleanup on exit\n\n# Or use try/finally\nscope = None\ntry:\n    scope = connect_to_scope("192.168.1.50")\n    # Your code here\nfinally:\n    if scope:\n        scope.close()'),
      callout('tip', 'Code Review Checklist', 'Before deploying automation scripts: 1) Error handling for all operations, 2) Logging for debugging, 3) Resource cleanup, 4) Configuration externalized, 5) Functions are testable.'),
    ],
    relatedArticles: ['error_handling', 'generated_script_structure', 'running_locally'],
  },
  
  {
    id: 'version_compatibility',
    title: 'Version Compatibility: Firmware Requirements and Compatibility Matrices',
    category: 'connection_hardware',
    subcategory: 'instrument_quirks',
    content: [
      heading(2, 'Tektronix Instrument Compatibility'),
      paragraph('Different Tektronix instrument models and firmware versions have varying capabilities. Understanding compatibility ensures your automation works reliably.'),
      heading(3, 'Checking Firmware Version'),
      paragraph('Always check firmware version before using advanced features:'),
      code('python', '# Query firmware version\nidn = scope.query("*IDN?")\n# Returns: "TEKTRONIX,MSO64,C012345,CF:91.1.0 FV:1.0.0"\n# CF = Control Firmware, FV = FPGA Version\n\n# Parse version\nparts = idn.split(",")\nfirmware = parts[3] if len(parts) > 3 else "Unknown"\nprint(f"Firmware: {firmware}")'),
      heading(3, 'TekHSI Compatibility'),
      paragraph('TekHSI requires specific firmware versions:'),
      paragraph('• MSO 4/5/6/7 Series: Firmware 1.0.0 or later'),
      paragraph('• Requires SFP+ port (10 Gbps Ethernet)'),
      paragraph('• Windows/Linux only (not macOS)'),
      paragraph('• Check with: `scope.query(":SYSTem:VERSion?")`'),
      code('python', 'def check_tekhsi_compatibility(scope):\n    """Check if scope supports TekHSI"""\n    try:\n        idn = scope.query("*IDN?")\n        model = idn.split(",")[1]  # Get model number\n        \n        # Check if MSO 4/5/6/7 Series\n        if not any(x in model for x in ["MSO4", "MSO5", "MSO6", "MSO7"]):\n            return False, "Not MSO 4/5/6/7 Series"\n        \n        # Check firmware\n        version = scope.query(":SYSTem:VERSion?")\n        # Parse and compare version\n        \n        return True, "TekHSI compatible"\n    except:\n        return False, "Could not determine compatibility"'),
      heading(3, 'SCPI Command Compatibility'),
      paragraph('Some SCPI commands are model-specific:'),
      code('python', 'def safe_command(scope, command, fallback=None):\n    """Execute command with fallback if not supported"""\n    try:\n        scope.write(command)\n        return True\n    except pyvisa.VisaIOError as e:\n        if "not supported" in str(e).lower() or "illegal" in str(e).lower():\n            if fallback:\n                logging.warning(f"Command {command} not supported, using fallback")\n                scope.write(fallback)\n                return True\n            else:\n                logging.error(f"Command {command} not supported on this model")\n                return False\n        raise'),
      heading(3, 'Backend Compatibility Matrix'),
      paragraph('PyVISA: Works with all Tektronix instruments (all models, all firmware)'),
      paragraph('tm_devices: Works with modern Tektronix instruments (2010+), requires specific drivers per model'),
      paragraph('TekHSI: Only MSO 4/5/6/7 Series, firmware 1.0.0+, with SFP+ port'),
      heading(3, 'Checking Model and Capabilities'),
      code('python', 'def get_instrument_info(scope):\n    """Get detailed instrument information"""\n    idn = scope.query("*IDN?")\n    manufacturer, model, serial, firmware = idn.split(",")\n    \n    # Query additional capabilities\n    try:\n        channels = int(scope.query(":SYSTem:CHANnel:COUNt?"))\n    except:\n        channels = "Unknown"\n    \n    return {\n        "manufacturer": manufacturer,\n        "model": model,\n        "serial": serial,\n        "firmware": firmware,\n        "channels": channels\n    }'),
      callout('warning', 'Always Check Compatibility', 'Before using advanced features (TekHSI, specific SCPI commands), verify your instrument model and firmware version support them.'),
    ],
    relatedArticles: ['tekhsi_deep_dive', 'mso_456_permissions', 'backend_comparison'],
  },
  
  {
    id: 'security_considerations',
    title: 'Security Considerations: Network Security, Firewall Configuration, Secure Connections',
    category: 'connection_hardware',
    subcategory: 'physical_connectivity',
    content: [
      heading(2, 'Securing Your Tektronix Instrument Network'),
      paragraph('When connecting Tektronix instruments to networks, security is crucial, especially in production environments.'),
      heading(3, '1. Network Isolation'),
      paragraph('Best practice: Isolate test equipment on a separate network:'),
      paragraph('• Use a dedicated switch/router for instruments'),
      paragraph('• Don\'t connect instruments directly to corporate networks'),
      paragraph('• Use VLANs to segment instrument traffic'),
      paragraph('• Consider a separate subnet (e.g., 192.168.100.x)'),
      heading(3, '2. Firewall Configuration'),
      paragraph('Configure firewalls to allow only necessary ports:'),
      paragraph('• Port 1024 (VXI-11) - Required for SCPI over Ethernet'),
      paragraph('• Port 4000/5025 (Raw sockets) - Optional, only if using sockets'),
      paragraph('• Port 80 (HTTP) - Optional, for LXI web interface'),
      paragraph('• Block all other ports'),
      code('python', '# Windows Firewall example (run as admin)\n# Allow VXI-11 (port 1024)\nnetsh advfirewall firewall add rule name="Tektronix VXI-11" dir=in action=allow protocol=TCP localport=1024\n\n# Allow specific instrument IP only\nnetsh advfirewall firewall add rule name="Tektronix Scope" dir=in action=allow protocol=TCP localport=1024 remoteip=192.168.1.50'),
      heading(3, '3. Static IP vs. DHCP'),
      paragraph('For automation, use static IPs:'),
      paragraph('• Prevents IP changes that break scripts'),
      paragraph('• Easier firewall rules (specific IPs)'),
      paragraph('• More predictable network behavior'),
      paragraph('• Set on instrument: Utility → I/O → Network → Static IP'),
      heading(3, '4. Authentication (MSO 4/5/6/7 Series)'),
      paragraph('Enable authentication on Windows-based scopes:'),
      paragraph('• Utility → System → Security → Enable Authentication'),
      paragraph('• Set strong passwords for Automation account'),
      paragraph('• Disable User account if not needed'),
      paragraph('• Note: Authentication may require additional setup in your scripts'),
      heading(3, '5. Secure Connections (HTTPS)'),
      paragraph('For LXI web interface, use HTTPS if available:'),
      code('python', '# Check if HTTPS is enabled\nimport requests\n\ntry:\n    response = requests.get("https://192.168.1.50", verify=False, timeout=2)\n    print("HTTPS enabled")\nexcept:\n    print("HTTPS not available, using HTTP")\n    # Note: HTTP is fine for isolated lab networks'),
      heading(3, '6. Script Security'),
      paragraph('Protect sensitive information in scripts:'),
      code('python', '# BAD - Hardcoded credentials\nscope = connect_with_password("192.168.1.50", "password123")\n\n# GOOD - Use environment variables\nimport os\npassword = os.getenv("SCOPE_PASSWORD")\nscope = connect_with_password("192.168.1.50", password)\n\n# Or use config file (excluded from git)\n# .gitignore: config.json'),
      heading(3, '7. Network Monitoring'),
      paragraph('Monitor instrument network traffic:'),
      paragraph('• Use network monitoring tools to detect unauthorized access'),
      paragraph('• Log all SCPI connections'),
      paragraph('• Set up alerts for unusual activity'),
      callout('warning', 'Production Networks', 'Never connect instruments with automation enabled directly to production networks. Always use isolated test networks or VPNs.'),
    ],
    relatedArticles: ['direct_pc_to_scope', 'mso_456_permissions', 'finding_ip_address'],
  },
  
  {
    id: 'common_scpi_patterns',
    title: 'Common SCPI Patterns: Reusable Command Patterns and Templates',
    category: 'measurements_commands',
    subcategory: 'query_write_concept',
    content: [
      heading(2, 'Reusable SCPI Patterns for Tektronix Instruments'),
      paragraph('These common patterns will save you time when automating Tektronix oscilloscopes.'),
      heading(3, '1. Setup Pattern (Reset and Configure)'),
      code('python', 'def setup_scope(scope, channel=1, scale=0.5, offset=0, coupling="DC"):\n    """Standard scope setup pattern"""\n    scope.write("*RST")  # Reset to defaults\n    scope.query("*OPC?")  # Wait for reset\n    \n    # Configure channel\n    scope.write(f":CH{channel}:SCAle {scale}")\n    scope.write(f":CH{channel}:OFFSet {offset}")\n    scope.write(f":CH{channel}:COUPling {coupling}")\n    scope.write(f":SELect:CH{channel} ON")  # Enable channel\n    \n    # Verify settings\n    actual_scale = float(scope.query(f":CH{channel}:SCAle?"))\n    return actual_scale'),
      heading(3, '2. Acquisition Pattern'),
      code('python', 'def acquire_single(scope, channel=1, num_avg=1):\n    """Acquire single waveform with optional averaging"""\n    # Set data source\n    scope.write(f":DATa:SOUrce CH{channel}")\n    \n    # Configure acquisition\n    if num_avg > 1:\n        scope.write(":ACQuire:MODe AVErage")\n        scope.write(f":ACQuire:NUMAVg {num_avg}")\n    else:\n        scope.write(":ACQuire:MODe SAMPLE")\n    \n    # Trigger single acquisition\n    scope.write(":ACQuire:STOPAfter SEQUence")\n    scope.write(":ACQuire:STATE RUN")\n    scope.query("*OPC?")  # Wait for acquisition\n    \n    # Read waveform\n    scope.write(":WAVeform:FORMat RIBinary")\n    scope.write(":WAVeform:DATA?")\n    return scope.read_raw()'),
      heading(3, '3. Measurement Pattern'),
      code('python', 'def get_measurement(scope, measurement_type, source="CH1"):\n    """Get a measurement value"""\n    # Common measurements: FREQuency, PERiod, VOLTage:AMPLitude, etc.\n    scope.write(f":MEASure:{measurement_type} {source}")\n    scope.query("*OPC?")  # Wait for measurement\n    \n    # Read measurement value\n    value = float(scope.query(f":MEASure:{measurement_type}? {source}"))\n    return value\n\n# Usage\nfreq = get_measurement(scope, "FREQuency", "CH1")\namplitude = get_measurement(scope, "VOLTage:AMPLitude", "CH1")'),
      heading(3, '4. Trigger Setup Pattern'),
      code('python', 'def setup_trigger(scope, trigger_type="EDGE", source="CH1", level=0.0, slope="RISing"):\n    """Configure trigger settings"""\n    scope.write(f":TRIGger:TYPe {trigger_type}")\n    scope.write(f":TRIGger:{trigger_type}:SOUrce {source}")\n    scope.write(f":TRIGger:{trigger_type}:LEVel {level}")\n    \n    if trigger_type == "EDGE":\n        scope.write(f":TRIGger:EDGE:SLOpe {slope}")\n    \n    # Verify trigger level\n    actual_level = float(scope.query(f":TRIGger:{trigger_type}:LEVel?"))\n    return actual_level'),
      heading(3, '5. Screenshot Pattern'),
      code('python', 'def save_screenshot(scope, filename, inksaver=True):\n    """Save scope screenshot with InkSaver"""\n    if inksaver:\n        scope.write("SAVe:IMAGe:INKSaver ON")\n    \n    scope.write("SAVe:IMAGe:FILEFormat PNG")\n    scope.write(f"SAVe:IMAGe \'C:\\\\{filename}\'")\n    scope.query("*OPC?")  # Wait for save\n    \n    # For hardcopy (stream bytes):\n    # scope.write("HARDCopy:FORMat PNG")\n    # image_data = scope.query("HARDCopy:DATA?")\n    # return image_data'),
      heading(3, '6. Multi-Channel Pattern'),
      code('python', 'def setup_multi_channel(scope, channels_config):\n    """Configure multiple channels at once"""\n    # channels_config = {1: {"scale": 0.5, "offset": 0}, 2: {"scale": 1.0, "offset": 0.1}}\n    \n    for ch, config in channels_config.items():\n        scope.write(f":CH{ch}:SCAle {config[\'scale\']}")\n        scope.write(f":CH{ch}:OFFSet {config[\'offset\']}")\n        scope.write(f":SELect:CH{ch} ON")\n    \n    scope.query("*OPC?")  # Wait for all channels'),
      heading(3, '7. Waveform Export Pattern'),
      code('python', 'def export_waveform(scope, channel=1, filename="waveform.csv"):\n    """Export waveform to file on scope, then download"""\n    # Set source\n    scope.write(f":DATa:SOUrce CH{channel}")\n    \n    # Configure waveform format\n    scope.write(":WAVeform:FORMat ASCii")  # ASCII for CSV\n    scope.write(":WAVeform:POINts 10000")  # Limit points for CSV\n    \n    # Save to scope\n    scope.write(f"SAVe:WAVeform \'C:\\\\{filename}\'")\n    scope.query("*OPC?")  # Wait for save\n    \n    # Note: Downloading requires file transfer protocol\n    # (Implementation depends on backend)'),
      callout('tip', 'Create a Library', 'Save these patterns in a reusable Python module (e.g., `tek_scpi_patterns.py`) so you can import them in all your automation scripts.'),
    ],
    relatedArticles: ['query_vs_write', 'setting_vs_querying', 'inksaver_guide', 'binary_vs_ascii'],
  },
  
  {
    id: 'pi_command_translator',
    title: 'PI Command Translator: Migrating Legacy Commands to Modern Oscilloscopes',
    category: 'measurements_commands',
    subcategory: 'query_write_concept',
    content: [
      heading(2, 'What is the PI Command Translator?'),
      paragraph('The Programming Interface (PI) Command Translator is a built-in feature in modern Tektronix oscilloscopes (firmware v1.30+) that automatically translates legacy SCPI commands from older oscilloscope models into commands compatible with newer platforms.'),
      paragraph('This feature is essential when migrating automation scripts from older scopes (like DPO7000, MSO/DPO5000) to newer models (2 Series MSO, 4 Series MSO, 5 Series MSO, 6 Series MSO, MSO58LP, LPD64).'),
      callout('info', 'Supported Instruments', 'The PI Translator is available on: 2 Series MSO, 4 Series MSO, 5 Series MSO, 5 Series B MSO, 6 Series MSO, 6 Series B MSO, MSO58LP, LPD64 with firmware v1.30 or higher.'),
      heading(3, 'How It Works'),
      paragraph('The PI Translator acts as a "dictionary" that intercepts legacy commands as they arrive at the oscilloscope, compares them to a translation table, and automatically converts them to modern equivalents before execution.'),
      paragraph('• Runs passively in the scope application (no client-side installation needed)'),
      paragraph('• Intercepts commands during reception'),
      paragraph('• Translates using a Compatibility File (XML)'),
      paragraph('• Sends translated commands to scope firmware'),
      heading(2, 'Enabling the PI Translator'),
      paragraph('There are two ways to enable the PI Translator:'),
      heading(3, 'Method 1: Front Panel'),
      paragraph('1. Navigate to Utility menu at the top of the scope application'),
      paragraph('2. Select User Preferences → Other'),
      paragraph('3. Toggle "Programmatic Interface Backward Compatibility" to On'),
      heading(3, 'Method 2: SCPI Command'),
      code('python', '# Enable PI Translator via SCPI\nscope.write("COMPatibility:ENABLE 1")\n\n# Disable if needed\nscope.write("COMPatibility:ENABLE 0")'),
      heading(2, 'Compatibility File Location'),
      paragraph('The translation dictionary is stored in a Compatibility.xml file. The location depends on the oscilloscope\'s operating system:'),
      heading(3, 'Embedded Linux (Standard OS)'),
      code('bash', 'C:/PICompatibility/Compatibility.xml'),
      heading(3, 'Windows-Based Scopes'),
      code('bash', 'C:\\Users\\Public\\Tektronix\\TekScope\\PICompatibility\\Compatibility.xml'),
      callout('warning', 'Backup First', 'Always copy the original Compatibility.xml file before making modifications. This allows you to restore defaults if needed.'),
      heading(2, 'Translation Capabilities'),
      paragraph('The PI Translator supports several translation patterns:'),
      heading(3, '1. One-to-One Translation'),
      paragraph('Simple direct command replacement. For example, translating legacy `MATH<x>:DEFine` to modern `MATH:MATH<x>:DEFine`.'),
      code('xml', '<keyword name="MATH">\n  <keyword name="DEFine" leaf="1" command="1" query="1">\n    <translation header=":math:math:define"/>\n  </keyword>\n</keyword>'),
      heading(3, '2. One-to-Many Translation'),
      paragraph('A single legacy command translates to multiple modern commands. Useful when legacy commands had implicit behaviors that must be explicit in modern scopes.'),
      code('xml', '<!-- Legacy: MATH<x>:NUMAVg sets averages and implicitly enables averaging -->\n<!-- Modern: Requires explicit enable command -->\n<keyword name="MATH">\n  <keyword name="NUMAVg" leaf="1" command="1" query="1">\n    <translation header=":math:math:avg:weight" reuseSuffix="1"/>\n    <translation header=":math:math:avg:mode" argument="1" query="0"/>\n  </keyword>\n</keyword>'),
      heading(3, '3. Argument-Dependent Translation'),
      paragraph('The translation depends on the command argument. Different argument values map to different modern commands.'),
      code('xml', '<!-- Legacy: CH<x>:PRObe:INPUTMode {DEFault|DIFFerential|COMmonmode|A|B} -->\n<!-- Modern: CH<x>:PRObe:INPUTMode {A|B|C|D} -->\n<keyword name="CH">\n  <keyword name="PRObe">\n    <keyword name="INPUTMode" leaf="1" command="1" query="1">\n      <translation header=":ch:probe:inputmode" sensitiveArgument="DIFFerential" argument="D"/>\n      <translation header=":ch:probe:inputmode" sensitiveArgument="COMmon" argument="C"/>\n      <translation header=":ch:probe:inputmode" sensitiveArgument="A" argument="A"/>\n      <translation header=":ch:probe:inputmode" sensitiveArgument="B" argument="B"/>\n    </keyword>\n  </keyword>\n</keyword>'),
      heading(3, '4. Reuse Argument Translation'),
      paragraph('Translates a global legacy setting to per-channel modern commands. Useful when legacy scopes had global settings that are now channel-specific.'),
      code('xml', '<!-- Legacy: TRIGger:{A|B}:LEVel (global) -->\n<!-- Modern: TRIGger:{A|B}:LEVel:CH<x> (per-channel) -->\n<keyword name="TRIGger">\n  <keyword name="LEVel" leaf="1" command="1" query="0">\n    <translation header=":trigger:?:level:ch1" reuseSuffix="1" reuseArgument="1" countOfArguments="1"/>\n    <translation header=":trigger:?:level:ch2" reuseSuffix="1" reuseArgument="1" countOfArguments="1"/>\n    <translation header=":trigger:?:level:ch3" reuseSuffix="1" reuseArgument="1" countOfArguments="1"/>\n    <translation header=":trigger:?:level:ch4"/>\n  </keyword>\n</keyword>'),
      heading(2, 'Default Translation Coverage'),
      paragraph('The PI Translator comes with built-in translations for many common operations:'),
      paragraph('• Horizontal and vertical settings'),
      paragraph('• Trigger configuration'),
      paragraph('• Acquisition modes'),
      paragraph('• Waveform transfer commands'),
      paragraph('• Display settings'),
      paragraph('However, some automation sequences may require custom translations for specialized commands.'),
      heading(2, 'Creating Custom Translations'),
      paragraph('To add custom translations:'),
      paragraph('1. Locate the Compatibility.xml file on your oscilloscope'),
      paragraph('2. Copy it to a safe location as a backup'),
      paragraph('3. Edit the XML file using a text editor (Notepad++ recommended)'),
      paragraph('4. Add your translation entries following the XML schema'),
      paragraph('5. Save the file back to the oscilloscope'),
      paragraph('6. Restart the oscilloscope or reload the compatibility file'),
      callout('tip', 'XML Editor', 'Use Notepad++ (https://notepad-plus-plus.org/) for editing XML files. It provides syntax highlighting and bracket matching, making it easier to work with the translation structure.'),
      heading(2, 'Why This Matters for Automation'),
      paragraph('The PI Command Translator is crucial for automation because:'),
      paragraph('• **Migration Path**: Allows gradual migration from legacy to modern scopes without rewriting all automation scripts'),
      paragraph('• **Backward Compatibility**: Existing scripts continue to work on new hardware'),
      paragraph('• **Reduced Development Time**: No need to immediately update all command syntax'),
      paragraph('• **Flexibility**: Custom translations can handle instrument-specific requirements'),
      paragraph('• **Testing**: Test new scopes with existing scripts before full migration'),
      heading(2, 'Best Practices'),
      paragraph('When using the PI Translator:'),
      paragraph('1. **Test Thoroughly**: Verify that translated commands produce expected results'),
      paragraph('2. **Document Custom Translations**: Keep notes on any custom translations you add'),
      paragraph('3. **Version Control**: Track changes to Compatibility.xml files'),
      paragraph('4. **Gradual Migration**: Use the translator as a bridge while updating scripts to modern commands'),
      paragraph('5. **Check Firmware Updates**: New firmware versions may add or change default translations'),
      callout('warning', 'Not a Permanent Solution', 'While the PI Translator is excellent for migration, consider updating scripts to use modern commands directly for better long-term maintainability and to take advantage of new features.'),
      heading(2, 'Additional Resources'),
      paragraph('For detailed information on creating custom translations, XML schema reference, and advanced translation patterns, refer to the official Tektronix PI Translator Manual.'),
      paragraph('The technical brief provides comprehensive examples and detailed explanations of all translation attributes and capabilities.'),
      callout('info', 'Source Article', 'This article is based on the Tektronix Technical Brief: "Introduction to the Programming Interface Command Translator on Oscilloscopes". Read the full article at: https://www.tek.com/en/documents/technical-brief/pi-command-translator-on-oscilloscopes-tech-brief'),
    ],
    relatedArticles: ['common_scpi_patterns', 'version_compatibility', 'query_vs_write'],
  },
  
  {
    id: 'data_visualization',
    title: 'Data Visualization: Tips for Processing and Visualizing Acquired Data',
    category: 'scripting_workflow',
    subcategory: 'advanced_patterns',
    content: [
      heading(2, 'Visualizing Tektronix Waveform Data'),
      paragraph('After acquiring data from Tektronix oscilloscopes, visualization helps understand and analyze the measurements.'),
      heading(3, '1. Basic Plotting with Matplotlib'),
      code('python', 'import numpy as np\nimport matplotlib.pyplot as plt\nfrom struct import unpack\n\ndef plot_waveform(binary_data, x_incr, x_zero, y_incr, y_zero, y_origin):\n    """Plot waveform from binary data"""\n    # Parse binary data (skip IEEE-488.2 header)\n    if binary_data[0] == ord(\'#\'):\n        # Skip header: #N<digits><N bytes>\n        header_len = int(chr(binary_data[1]))\n        data_start = 2 + header_len\n        num_bytes = int(binary_data[2:data_start].decode())\n        waveform_bytes = binary_data[data_start:data_start+num_bytes]\n    else:\n        waveform_bytes = binary_data\n    \n    # Convert to numpy array (Big Endian float32)\n    waveform = np.frombuffer(waveform_bytes, dtype=">f4")\n    \n    # Convert to voltage and time\n    voltages = (waveform - y_origin) * y_incr + y_zero\n    num_points = len(voltages)\n    times = np.arange(num_points) * x_incr + x_zero\n    \n    # Plot\n    plt.figure(figsize=(12, 6))\n    plt.plot(times, voltages)\n    plt.xlabel("Time (s)")\n    plt.ylabel("Voltage (V)")\n    plt.title("Oscilloscope Waveform")\n    plt.grid(True)\n    plt.show()\n    \n    return times, voltages'),
      heading(3, '2. Multi-Channel Overlay'),
      code('python', 'def plot_multi_channel(waveforms_dict):\n    """Plot multiple channels on same plot"""\n    # waveforms_dict = {"CH1": (times, voltages), "CH2": (times, voltages), ...}\n    \n    plt.figure(figsize=(12, 6))\n    \n    for channel, (times, voltages) in waveforms_dict.items():\n        plt.plot(times, voltages, label=channel, linewidth=2)\n    \n    plt.xlabel("Time (s)")\n    plt.ylabel("Voltage (V)")\n    plt.title("Multi-Channel Waveform")\n    plt.legend()\n    plt.grid(True)\n    plt.show()'),
      heading(3, '3. Statistical Analysis'),
      code('python', 'import numpy as np\n\ndef analyze_waveform(voltages):\n    """Calculate waveform statistics"""\n    stats = {\n        "mean": np.mean(voltages),\n        "std": np.std(voltages),\n        "min": np.min(voltages),\n        "max": np.max(voltages),\n        "peak_to_peak": np.ptp(voltages),\n        "rms": np.sqrt(np.mean(voltages**2))\n    }\n    \n    # Frequency analysis (FFT)\n    fft = np.fft.fft(voltages)\n    freqs = np.fft.fftfreq(len(voltages))\n    \n    # Find dominant frequency\n    magnitude = np.abs(fft)\n    dominant_freq_idx = np.argmax(magnitude[1:len(magnitude)//2]) + 1\n    stats["dominant_frequency"] = freqs[dominant_freq_idx]\n    \n    return stats'),
      heading(3, '4. Time-Domain vs. Frequency-Domain'),
      code('python', 'def plot_time_and_freq(times, voltages, sample_rate):\n    """Plot both time and frequency domain"""\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))\n    \n    # Time domain\n    ax1.plot(times, voltages)\n    ax1.set_xlabel("Time (s)")\n    ax1.set_ylabel("Voltage (V)")\n    ax1.set_title("Time Domain")\n    ax1.grid(True)\n    \n    # Frequency domain (FFT)\n    fft = np.fft.fft(voltages)\n    freqs = np.fft.fftfreq(len(voltages), 1/sample_rate)\n    magnitude = np.abs(fft)\n    \n    # Plot only positive frequencies\n    positive_freqs = freqs[:len(freqs)//2]\n    positive_magnitude = magnitude[:len(magnitude)//2]\n    \n    ax2.plot(positive_freqs, positive_magnitude)\n    ax2.set_xlabel("Frequency (Hz)")\n    ax2.set_ylabel("Magnitude")\n    ax2.set_title("Frequency Domain (FFT)")\n    ax2.grid(True)\n    ax2.set_xlim(0, sample_rate/2)  # Nyquist frequency\n    \n    plt.tight_layout()\n    plt.show()'),
      heading(3, '5. Export to Common Formats'),
      code('python', 'import pandas as pd\nimport numpy as np\n\ndef export_to_csv(times, voltages, filename="waveform.csv"):\n    """Export to CSV for Excel/analysis"""\n    df = pd.DataFrame({\n        "Time (s)": times,\n        "Voltage (V)": voltages\n    })\n    df.to_csv(filename, index=False)\n    print(f"Exported {len(df)} points to {filename}")\n\ndef export_to_hdf5(times, voltages, filename="waveform.h5"):\n    """Export to HDF5 for large datasets"""\n    import h5py\n    with h5py.File(filename, "w") as f:\n        f.create_dataset("time", data=times)\n        f.create_dataset("voltage", data=voltages)\n        f.attrs["description"] = "Tektronix oscilloscope waveform data"'),
      heading(3, '6. Interactive Plotting (Plotly)'),
      code('python', 'import plotly.graph_objects as go\n\ndef interactive_plot(times, voltages):\n    """Create interactive plot with zoom/pan"""\n    fig = go.Figure()\n    fig.add_trace(go.Scatter(\n        x=times,\n        y=voltages,\n        mode="lines",\n        name="Waveform"\n    ))\n    \n    fig.update_layout(\n        title="Interactive Waveform Plot",\n        xaxis_title="Time (s)",\n        yaxis_title="Voltage (V)",\n        hovermode="x unified"\n    )\n    \n    fig.show()  # Opens in browser'),
      callout('tip', 'Processing Large Datasets', 'For 10M+ point datasets, use downsampling for visualization. Plot every Nth point, or use decimation algorithms to reduce data while preserving important features.'),
    ],
    relatedArticles: ['binary_vs_ascii', 'record_length_vs_transfer_time', 'data_logging'],
  },
  
  {
    id: 'external_integration',
    title: 'External Integration: LabVIEW, MATLAB, and Other Automation Tools',
    category: 'scripting_workflow',
    subcategory: 'advanced_patterns',
    content: [
      heading(2, 'Integrating Tektronix Instruments with Other Tools'),
      paragraph('Sometimes you need to integrate Tektronix instrument control with existing automation frameworks.'),
      heading(3, '1. LabVIEW Integration'),
      paragraph('LabVIEW can control Tektronix instruments via VISA:'),
      paragraph('• Use LabVIEW\'s VISA functions (same as PyVISA)'),
      paragraph('• Resource string format: `TCPIP::192.168.1.50::INSTR`'),
      paragraph('• Use "VISA Write" and "VISA Read" blocks'),
      paragraph('• For Python scripts, call LabVIEW VIs using Python subprocess or COM'),
      code('python', '# Call LabVIEW VI from Python\nimport subprocess\n\n# If LabVIEW VI is compiled as executable\nresult = subprocess.run(\n    ["labview_vi.exe", "192.168.1.50"],\n    capture_output=True,\n    text=True\n)\n\n# Or use Python to generate SCPI, LabVIEW executes it\nscpi_commands = [\n    "*RST",\n    ":CH1:SCAle 0.5",\n    ":ACQuire:STATE RUN"\n]\n# Save to file, LabVIEW reads and executes'),
      heading(3, '2. MATLAB Integration'),
      paragraph('MATLAB has built-in instrument control:'),
      code('matlab', '% MATLAB code to control Tektronix scope\nscope = visadev("TCPIP::192.168.1.50::INSTR");\n\n% Write commands\nwriteline(scope, "*RST");\nwriteline(scope, ":CH1:SCAle 0.5");\n\n% Query responses\nidn = readline(scope);\n\n% Close connection\nclear scope'),
      paragraph('Or call Python scripts from MATLAB:'),
      code('matlab', '% Call Python script from MATLAB\nsystem("python tek_automation.py --visa TCPIP::192.168.1.50::INSTR");\n\n% Or use py.importlib to import Python modules\npy.importlib.import_module("pyvisa");'),
      heading(3, '3. Python as Middleware'),
      paragraph('Use Python scripts as a bridge between systems:'),
      code('python', '# Python script that other tools can call\nimport sys\nimport json\nimport pyvisa\n\ndef control_scope(ip, commands):\n    """Control scope, return results as JSON"""\n    rm = pyvisa.ResourceManager()\n    scope = rm.open_resource(f"TCPIP::{ip}::INSTR")\n    \n    results = []\n    for cmd in commands:\n        if "?" in cmd:\n            result = scope.query(cmd)\n            results.append({"command": cmd, "response": result})\n        else:\n            scope.write(cmd)\n            results.append({"command": cmd, "response": "OK"})\n    \n    scope.close()\n    return results\n\n# Called from command line\nif __name__ == "__main__":\n    ip = sys.argv[1]\n    commands = json.loads(sys.argv[2])\n    results = control_scope(ip, commands)\n    print(json.dumps(results))'),
      heading(3, '4. REST API Wrapper'),
      paragraph('Create a REST API wrapper around Python automation:'),
      code('python', '# Flask REST API for instrument control\nfrom flask import Flask, request, jsonify\nimport pyvisa\n\napp = Flask(__name__)\n\n@app.route("/scope/<ip>/command", methods=["POST"])\ndef execute_command(ip):\n    command = request.json.get("command")\n    \n    rm = pyvisa.ResourceManager()\n    scope = rm.open_resource(f"TCPIP::{ip}::INSTR")\n    \n    try:\n        if "?" in command:\n            result = scope.query(command)\n        else:\n            scope.write(command)\n            result = "OK"\n        \n        return jsonify({"success": True, "result": result})\n    except Exception as e:\n        return jsonify({"success": False, "error": str(e)}), 500\n    finally:\n        scope.close()\n\n# Usage: POST to http://localhost:5000/scope/192.168.1.50/command\n# Body: {"command": "*IDN?"}'),
      heading(3, '5. Shared Data Formats'),
      paragraph('Use common file formats for data exchange:'),
      code('python', '# Export data in formats other tools can read\nimport numpy as np\nimport pandas as pd\n\n# CSV (universal)\ndf = pd.DataFrame({"time": times, "voltage": voltages})\ndf.to_csv("waveform.csv")\n\n# HDF5 (MATLAB, Python, LabVIEW)\nimport h5py\nwith h5py.File("waveform.h5", "w") as f:\n    f.create_dataset("time", data=times)\n    f.create_dataset("voltage", data=voltages)\n\n# MATLAB .mat format\nfrom scipy.io import savemat\nsavemat("waveform.mat", {"time": times, "voltage": voltages})'),
      heading(3, '6. National Instruments TestStand'),
      paragraph('TestStand can execute Python scripts:'),
      paragraph('• Use "Run LabVIEW VI" step to call Python via subprocess'),
      paragraph('• Or use "Run External Process" step'),
      paragraph('• Python script receives parameters, returns results'),
      paragraph('• TestStand handles sequencing and reporting'),
      callout('tip', 'Choose the Right Tool', 'Use Python for flexibility and rapid development. Use LabVIEW/MATLAB when you need their specific analysis capabilities. Use TestStand for test sequencing and reporting.'),
    ],
    relatedArticles: ['generated_script_structure', 'data_logging', 'automation_best_practices'],
  },
];

// Categories
export const categories: Category[] = [
  {
    id: 'connection_hardware',
    title: 'Connection & Hardware',
    description: 'The Physical Layer - IP addresses, cables, VISA protocols',
    subcategories: [
      {
        id: 'physical_connectivity',
        title: 'Physical Connectivity',
        articles: articles.filter(a => a.subcategory === 'physical_connectivity'),
      },
      {
        id: 'visa_protocol',
        title: 'The VISA Protocol',
        articles: articles.filter(a => a.subcategory === 'visa_protocol'),
      },
      {
        id: 'instrument_quirks',
        title: 'Instrument-Specific Quirks',
        articles: articles.filter(a => a.subcategory === 'instrument_quirks'),
      },
    ],
  },
  {
    id: 'engine_room',
    title: 'The Engine Room',
    description: 'Backend Drivers - PyVISA, tm_devices, TekHSI',
    subcategories: [
      {
        id: 'driver_deep_dives',
        title: 'Driver Deep Dives',
        articles: articles.filter(a => a.subcategory === 'driver_deep_dives'),
      },
      {
        id: 'comparison_guides',
        title: 'Comparison Guides',
        articles: articles.filter(a => a.subcategory === 'comparison_guides'),
      },
    ],
  },
  {
    id: 'measurements_commands',
    title: 'Measurements & Commands',
    description: 'SCPI Strategy - Queries, waveforms, screenshots',
    subcategories: [
      {
        id: 'query_write_concept',
        title: 'Query vs. Write',
        articles: articles.filter(a => a.subcategory === 'query_write_concept'),
      },
      {
        id: 'waveform_acquisition',
        title: 'Waveform Acquisition',
        articles: articles.filter(a => a.subcategory === 'waveform_acquisition'),
      },
      {
        id: 'screenshots_files',
        title: 'Screenshots & Files',
        articles: articles.filter(a => a.subcategory === 'screenshots_files'),
      },
    ],
  },
  {
    id: 'scripting_workflow',
    title: 'Scripting & Workflow',
    description: 'The Output - Running scripts, error handling, automation',
    subcategories: [
      {
        id: 'ui_to_code',
        title: 'From UI to Code',
        articles: articles.filter(a => a.subcategory === 'ui_to_code'),
      },
      {
        id: 'advanced_patterns',
        title: 'Advanced Patterns',
        articles: articles.filter(a => a.subcategory === 'advanced_patterns'),
      },
    ],
  },
  {
    id: 'troubleshooting',
    title: 'Troubleshooting',
    description: 'The "Fix It" Guide - Common errors and solutions',
    subcategories: [
      {
        id: 'connection_errors',
        title: 'Connection Errors',
        articles: articles.filter(a => a.subcategory === 'connection_errors'),
      },
      {
        id: 'data_errors',
        title: 'Data Errors',
        articles: articles.filter(a => a.subcategory === 'data_errors'),
      },
      {
        id: 'driver_issues',
        title: 'Driver Issues',
        articles: articles.filter(a => a.subcategory === 'driver_issues'),
      },
    ],
  },
];

// Helper function to get article by ID
export const getArticleById = (id: string): Article | undefined => {
  return articles.find(article => article.id === id);
};

// Helper function to search articles
export const searchArticles = (query: string): Article[] => {
  if (!query.trim()) return articles;
  
  const lowerQuery = query.toLowerCase();
  return articles.filter(article => {
    const titleMatch = article.title.toLowerCase().includes(lowerQuery);
    const contentMatch = article.content.some(block => 
      block.text?.toLowerCase().includes(lowerQuery)
    );
    return titleMatch || contentMatch;
  });
};

